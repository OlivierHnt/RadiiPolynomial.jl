var documenterSearchIndex = {"docs":
[{"location":"radii_polynomial_approach/#State-of-the-art","page":"State of the art","title":"State of the art","text":"The study of complex dynamical systems requires numerical computations to access the dynamics. While numerical methods provide accurate approximations, they often come at the cost of rounding, discretization errors and the surrender of an a posteriori error bound between the approximation and the exact solution of the original problem.\n\nComputer-assisted proofs aim to validate numerical simulations and derive mathematical theorems, thereby binding computational results with topological, geometric and qualitative methods of nonlinear theory.\n\nRadiiPolynomial.jl is a Julia package to conduct the computational steps of a type of computer-assisted proofs referred to as the radii polynomial approach (see the next section below).","category":"section"},{"location":"radii_polynomial_approach/#radii_polynomial_approach","page":"State of the art","title":"Radii polynomial approach","text":"Given a problem in dynamical systems (e.g. existence of an invariant set, stability analysis, etc.), one approach of computer-assisted proofs consists in representing the desired solution tx as an isolated fixed-point in a Banach space X. The assistance of the computer is used to verify that the corresponding fixed-point operator T abides by the Banach Fixed-Point Theorem in a vicinity of a numerical approximation bx. Note that a particular case of this procedure is the well-known Newton-Kantorovich Theorem.\n\nWe refer to this strategy as the radii polynomial approach since, in practice, we prove the contraction of T in balls whose radii are determined by the roots of a polynomial. For the sake of completeness, we report the fundamental principles in the following theorem.\n\n<div class=\"theorem\" text=\"Radii Polynomial Theorem\">\n\nLet X be a Banach space, U an open subset of X, T in C^1(U X) an operator, bx in U and R  0 such that textcl( B_R(bx) ) subset U.\n\n(First-order) Suppose Y Z_1 ge 0 satisfy\n\nbeginaligned\nT(bx) - bx_X le Y\nsup_x in textcl( B_R(bx) ) DT(x)_mathscrB(X X) le Z_1\nendaligned\n\nand define the radii polynomial by p(r) bydef Y + (Z_1 - 1) r. If there exists a radius barr in 0 R such that p(barr) le 0 and Z_1  1, then T has a unique fixed-point tx in textcl( B_barr (bx) ).\n\n(Second-order) Suppose Y Z_1 Z_2 ge 0 satisfy\n\nbeginaligned\nT(bx) - bx_X le Y\nDT(bx)_mathscrB(X X) le Z_1\nDT(x) - DT(bx)_mathscrB(X X) le Z_2 x - bx_X qquad textfor all  x in textcl( B_R(bx) )\nendaligned\n\nand define the radii polynomial by p(r) bydef Y + (Z_1 - 1) r + fracZ_22 r^2. If there exists a radius barr in 0 R such that p(barr) le 0 and Z_1 + Z_2 barr  1, then T has a unique fixed-point tx in textcl( B_barr (bx) ).\n\n</div>\n<br>\n\nThe set of all possible radii is called the interval of existence. Its minimum gives the sharpest computed a posteriori error bound on bx. On the other hand, its maximum represents the largest computed radius of the ball, centred at bx, within which the solution is unique.","category":"section"},{"location":"radii_polynomial_approach/#Further-readings","page":"State of the art","title":"Further readings","text":"A mini-lecture series on validated numerics can be found here.","category":"section"},{"location":"radii_polynomial_approach/#RadiiPolynomial.interval_of_existence","page":"State of the art","title":"RadiiPolynomial.interval_of_existence","text":"interval_of_existence(Y::Interval, Z‚ÇÅ::Interval, R::Real; verbose::Bool = false)\n\nReturn an interval and a boolean value with the following meaning:     - true: the interval corresponds to I subset 0 R such that Y + (Z_1 - 1) r le 0 for all r in I and Z_1  1.     - false: otherwise, and the interval is empty.\n\n\n\n\n\ninterval_of_existence(Y::Interval, Z‚ÇÅ::Interval, Z‚ÇÇ::Interval, R::Real; verbose::Bool = false)\n\nReturn an interval and a boolean value with the following meaning:     - true: the interval corresponds to I subset 0 R such that Y + (Z_1 - 1) r + Z_2 r^2  2 le 0 and Z_1 + Z_2 r  1 for all r in I.     - false: otherwise, and the interval is empty.\n\n\n\n\n\n","category":"function"},{"location":"manual/linear_operators/#Linear-operators","page":"Linear operators","title":"Linear operators","text":"A LinearOperator is a structure representing a linear operator from a VectorSpace to an other. More precisely, a LinearOperator is comprised of the three fields domain::VectorSpace, codomain::VectorSpace and coefficients::AbsractMatrix with matching dimensions and size.\n\nA = LinearOperator(Taylor(1), Taylor(1), [1 2 ; 3 4])\n\nThe three fields domain, codomain and coefficients are accessible via the respective functions of the same name.\n\ndomain(A)\ncodomain(A)\ncoefficients(A)\n\nFor convenience, the methods zeros, ones, fill and fill! are available:\n\ndom, codom = Taylor(1), Taylor(2)\nzeros(dom, codom)\nones(dom, codom)\nfill(2, dom, codom)\nfill!(zeros(dom, codom), 2)\n\nThe coefficients of a LinearOperator are indexed according to the indices of the domain and codomain (as given by indices).\n\nA[0:1,0:1] # indices(domain(A)), indices(codomain(A))\n\nWhen the domain and/or the codomain of a LinearOperator is a CartesianSpace, its coefficients can be thought of as a block matrix . The function component extracts a LinearOperator composing the cartesian space.\n\nB = LinearOperator(ParameterSpace() √ó Taylor(1)^2, ParameterSpace() √ó Taylor(1)^2, reshape(1:25, 5, 5))\nB[1:5,1:5] # indices(domain(B)), indices(codomain(B))\ncomponent(B, 1, 1) # extract the linear operator associated with the domain ParameterSpace() and codomain ParameterSpace()\ncomponent(B, 2, 2) # extract the linear operator associated with the domain Taylor(1)^2 and codomain Taylor(1)^2\ncomponent(component(B, 2, 2), 1, 1)\ncomponent(component(B, 2, 2), 2, 2)\n\nSimilarly, the function eachcomponent returns a Generator whose iterates yield each LinearOperator composing the cartesian space.","category":"section"},{"location":"manual/linear_operators/#Arithmetic","page":"Linear operators","title":"Arithmetic","text":"The addition and subtraction operations are implemented as the + and - functions respectively.\n\nC = LinearOperator(Taylor(1), Taylor(1), [1 2 ; 3 4])\nD = LinearOperator(Taylor(1), Taylor(2), [1 2 ; 3 4 ; 5 6])\nC + D\nC - D\nC + I\nC - I\n\nThe product between LinearOperator is implemented as the * and ^ functions. The division between LinearOperator is implemented as the \\ method.\n\nC * D\nC ^ 3\nC \\ C\n\nThe action of a LinearOperator is performed by the right product * of a LinearOperator with a Sequence; alternatively, LinearOperator defines a method on a Sequence representing *. Naturally, the resulting sequence is an element of the codomain of the LinearOperator.\n\nConversely, the operator \\ between a LinearOperator and a Sequence corresponds to the action of the inverse of the LinearOperator; the output sequence is an element of the domain of the LinearOperator.\n\nx = Sequence(Taylor(2), [1, 1, 1])\nC * x # C(x)\nD \\ x","category":"section"},{"location":"manual/linear_operators/#API","page":"Linear operators","title":"API","text":"","category":"section"},{"location":"manual/special_operators/#Special-operators","page":"Special operators","title":"Special operators","text":"In this section, we present several operations common to dynamical systems.","category":"section"},{"location":"manual/special_operators/#Projection","page":"Special operators","title":"Projection","text":"When working with SequenceSpace, one frequently needs to adjust the order of truncation of the chosen basis. This operation is implemented as the project and project! functions. In fact, these functions provide a general mechanism to retrieve a finite part of the infinite dimensional operators introduced later in this section.\n\nEach project or project! call verifies a compatibility criterion between spaces. For Sequence and LinearOperator, two VectorSpace are compatible if:\n\nall comprised SequenceSpace only differ from their order. For instance, Taylor(n) and Taylor(m) are compatible for any positive n::Int and m::Int. However, Taylor(n) and TensorSpace(Taylor(m), Fourier(k, 1.0)) are not compatible for any positive n::Int, m::Int and k::Int.\nall comprised CartesianSpace have the same number of cartesian products. For instance, CartesianPower(a, 2) and CartesianProduct(a, a) are compatible for any a::VectorSpace. However, CartesianProduct(a, b) and CartesianProduct(CartesianPower(a, 1), b) are not compatible for any a::VectorSpace and b::VectorSpace.\n\nA = LinearOperator(Taylor(1) ‚äó Chebyshev(1), Taylor(1) ‚äó Chebyshev(1), [1 0 0 0 ; 0 1 0 0 ; 0 0 1 0 ; 0 0 0 1]) # project(I, Taylor(1) ‚äó Chebyshev(1), Taylor(1) ‚äó Chebyshev(1))\nproject(A, Taylor(1) ‚äó Chebyshev(2), Taylor(2) ‚äó Chebyshev(1))\n\nMoreover, the following identifications are permitted:\n\na = Sequence(Taylor(1), [1, 1]) # 1 + x\nA = project(a, ParameterSpace(), Taylor(2))\nproject(A, space(a))","category":"section"},{"location":"manual/special_operators/#Multiplication","page":"Special operators","title":"Multiplication","text":"Let V be a SequenceSpace with discrete convolution * and a in V. The multiplication operator Multiplication represents the mapping mathcalM_a  V to V defined by\n\nmathcalM_a (b) bydef a * b qquad textfor all  b in V\n\nThe action of Multiplication is performed by the right product * of a Multiplication with a Sequence{<:SequenceSpace}; alternatively, Multiplication defines a method on a Sequence{<:SequenceSpace} representing *.\n\na = Sequence(Taylor(1), [1, 1]); # 1 + x\nb = Sequence(Taylor(2), [0, 0, 1]); # x^2\na * b\n‚Ñ≥ = Multiplication(a)\n‚Ñ≥ * b # ‚Ñ≥(b)\n\nA finite dimensional truncation of Multiplication may be obtained via project or project!.\n\nproject(‚Ñ≥, Taylor(2), codomain(*, Taylor(1), Taylor(2)))","category":"section"},{"location":"manual/special_operators/#Derivation-and-integration","page":"Special operators","title":"Derivation and integration","text":"Both Derivative and Integral have a field order::Union{Int,Tuple{Vararg{Int}}} to specify how many times the operator is composed with itself. No derivation or integration is performed whenever a value of 0 is given.\n\na = Sequence(Taylor(2), [1, 1, 1]); # 1 + x + x^2\ndifferentiate(a)\nùíü = Derivative(1)\nùíü * a # ùíü(a)\n\nA finite dimensional truncation of Derivative and Integral may be obtained via project or project!:\n\nproject(Derivative(1), Taylor(2), codomain(Derivative(1), Taylor(2)), Float64)\nproject(Integral(1), Taylor(2), codomain(Integral(1), Taylor(2)), Float64)","category":"section"},{"location":"manual/special_operators/#Evaluation","page":"Special operators","title":"Evaluation","text":"The evaluation operator Evaluation has a field value::Union{Number,Nothing,Tuple{Vararg{Union{Number,Nothing}}}} representing the evaluation point. No scaling is performed whenever a value of nothing is given.\n\na = Sequence(Taylor(2), [1, 1, 1]); # 1 + x + x^2\nevaluate(a, 0.1)\n‚Ñ∞ = Evaluation(0.1)\n‚Ñ∞ * a # ‚Ñ∞(a)\nb = Sequence(Taylor(1) ‚äó Fourier(1, 1.0), [0.5, 0.5, 0.0, 0.0, 0.5, 0.5]); # (1 + x) cos(y)\nevaluate(b, (0.1, nothing)) # Evaluation(0.1, nothing) * b\n\nMoreover, Evaluation is defined on CartesianSpace by acting component-wise.\n\nc = Sequence(Taylor(1)^2, [1, 1, 2, 2]); # 1 + x, 2 + 2x\nevaluate(c, 0.1) # Evaluation(0.1) * c\n\nA finite dimensional truncation of Evaluation may be obtained via project or project!:\n\nproject(Evaluation(0.1), Taylor(2), codomain(Evaluation(0.1), Taylor(2)), Float64)\n\nFurthermore, in the context of Evaluation, the concept of compatibility between two VectorSpace is more permissive to allow manipulating Evaluation more like a functional:\n\nproject(Evaluation(0.1), Taylor(2), ParameterSpace(), Float64)","category":"section"},{"location":"manual/special_operators/#Scale","page":"Special operators","title":"Scale","text":"The scale operator Scale has a field value::Union{Number,Tuple{Vararg{Number}}} representing the scaling factor. No scaling is performed whenever a value of 1 is given.\n\nnote: Note\nCurrently, only Taylor and Fourier spaces allow values different than 1.\n\na = Sequence(Taylor(2), [1, 1, 1]) # 1 + x + x^2\nscale(a, 2)\nùíÆ = Scale(2)\nùíÆ * a # ùíÆ(a)\n\nA finite dimensional truncation of Scale may be obtained via project or project!:\n\nproject(Scale(2), Taylor(2), codomain(Scale(2), Taylor(2)), Float64)","category":"section"},{"location":"manual/special_operators/#Shift","page":"Special operators","title":"Shift","text":"The shift operator Shift has a field value::Union{Number,Tuple{Vararg{Number}}} representing the shift. No shift is performed whenever a value of 0 is given.\n\nnote: Note\nCurrently, only Fourier space allows values different than 0.\n\na = Sequence(Fourier(1, 1.0), [0.5, 0.0, 0.5]) # cos(x)\nshift(a, œÄ)\nùíÆ = Shift(œÄ)\nùíÆ * a # ùíÆ(a)\n\nA finite dimensional truncation of Shift may be obtained via project or project!:\n\nproject(Shift(œÄ), Fourier(1, 1.0), codomain(Shift(œÄ), Fourier(1, 1.0)), Complex{Float64})","category":"section"},{"location":"manual/special_operators/#API","page":"Special operators","title":"API","text":"","category":"section"},{"location":"examples/infinite_dimensional_proofs/ode/lorenz_po/#Periodic-orbit-of-the-Lorenz-system","page":"Periodic orbit of the Lorenz system","title":"Periodic orbit of the Lorenz system","text":"In this example, we will prove the existence of a periodic orbit of the Lorenz system\n\nfracddt u(t) = f(u(t) sigma rho beta) bydef\nbeginpmatrix\nsigma(u_2(t) - u_1(t))\nu_1(t)(rho - u_3(t)) - u_2(t)\nu_1(t) u_2(t) - beta u_3(t)\nendpmatrix qquad sigma rho beta in mathbbR\n\nThe vector field f and its derivative with respect to u, denoted D_u f, may be implemented as follows:\n\nusing RadiiPolynomial\n\nfunction f!(f, u, œÉ, œÅ, Œ≤)\n    u‚ÇÅ, u‚ÇÇ, u‚ÇÉ = eachcomponent(u)\n    project!(component(f, 1), œÉ*(u‚ÇÇ - u‚ÇÅ))\n    project!(component(f, 2), u‚ÇÅ*(œÅ - u‚ÇÉ) - u‚ÇÇ)\n    project!(component(f, 3), u‚ÇÅ*u‚ÇÇ - Œ≤*u‚ÇÉ)\n    return f\nend\n\nfunction Df!(Df, u, œÉ, œÅ, Œ≤)\n    u‚ÇÅ, u‚ÇÇ, u‚ÇÉ = eachcomponent(u)\n    project!(component(Df, 1, 1), Multiplication(-œÉ*one(u‚ÇÅ)))\n    project!(component(Df, 1, 2), Multiplication(œÉ*one(u‚ÇÇ)))\n    project!(component(Df, 1, 3), Multiplication(zero(u‚ÇÉ)))\n    project!(component(Df, 2, 1), Multiplication(œÅ-u‚ÇÉ))\n    project!(component(Df, 2, 2), Multiplication(-one(u‚ÇÇ)))\n    project!(component(Df, 2, 3), Multiplication(-u‚ÇÅ))\n    project!(component(Df, 3, 1), Multiplication(u‚ÇÇ))\n    project!(component(Df, 3, 2), Multiplication(u‚ÇÅ))\n    project!(component(Df, 3, 3), Multiplication(-Œ≤*one(u‚ÇÉ)))\n    return Df\nend\nnothing # hide\n\nLet nu  1,\n\nell^1_nu mathbbZ bydef left u in mathbbC^mathbbZ    u_ell^1_nu mathbbZ bydef sum_k in mathbbZ u_k nu^k right\n\nand *  ell^1_nu mathbbZ times ell^1_nu mathbbZ to ell^1_nu mathbbZ be the discrete convolution given by\n\nu * v bydef left sum_l in mathbbZ u_k - l v_l right_k in mathbbZ qquad textfor all  u v in ell^1_nu mathbbZ\n\nFor any sequence u in ell^1_nu mathbbZ, the Fourier series sum_k in mathbbZ u_k e^i omega k t, for some frequency omega  0, defines an analytic 2piomega^-1-periodic function in C^omega(mathbbR mathbbC); while the discrete convolution * corresponds to the product of Fourier series in sequence space.\n\nThe Banach space ell^1_nu mathbbZ is a suitable space to represent each component of a periodic solution of the Lorenz system. Indeed, it is a standard result from ODE theory that analytic vector fields yield analytic solutions.[1]\n\n[1]: A. Hungria, J.-P. Lessard and J. D. Mireles James, Rigorous numerics for analytic solutions of differential equations: the radii polynomial approach, Mathematics of Computation, 85 (2016), 1427-1459.\n\nDefine the Banach space X bydef mathbbC times (ell^1_nu mathbbZ)^3 endowed with the norm x_X bydef gamma + u_1_ell^1_nu mathbbZ + u_2_ell^1_nu mathbbZ + u_3_ell^1_nu mathbbZ for all x = (gamma u_1 u_2 u_3) in X. It follows that the sequence of coefficients of a 2pigamma-periodic Fourier series solving the Lorenz equations is a zero of the mapping F  X to X given by\n\nF(x) bydef\nbeginpmatrix\nsum_j = 1^3 (sum_k = -K^K (u_j)_k - xi_j)eta_j\nleft gamma ( f(u sigma rho beta) )_k - i k u_k right_k in mathbbZ\nendpmatrix qquad textfor all  x = (gamma u_1 u_2 u_3) in textdomain(F)\n\nwhere xi in mathbbR^3 is a chosen approximate position of the periodic orbit at t = 0 and eta in mathbbR^3 the corresponding approximate tangent vector at xi. By means of the phase condition sum_j = 1^3 (sum_k = -n^n (u_j)_k - xi_j)eta_j, the translation invariance of the periodic orbit is removed.\n\nThe mapping F and its Fr√©chet derivative, denoted DF, may be implemented as follows:\n\nfunction F!(F, x, œÉ, œÅ, Œ≤, Œæ, Œ∑)\n    Œ≥, u = x[1], component(x, 2)\n\n    F[1] =\n        (component(u, 1)(0) - Œæ[1]) * Œ∑[1] +\n        (component(u, 2)(0) - Œæ[2]) * Œ∑[2] +\n        (component(u, 3)(0) - Œæ[3]) * Œ∑[3]\n\n    project!(component(F, 2), Œ≥ * f!(component(F, 2), u, œÉ, œÅ, Œ≤) - differentiate(u))\n\n    return F\nend\n\nfunction DF!(DF, x, œÉ, œÅ, Œ≤, Œ∑)\n    Œ≥, u = x[1], component(x, 2)\n\n    DF .= 0\n\n    component(component(DF, 1, 2), 1)[1,:] .= Œ∑[1]\n    component(component(DF, 1, 2), 2)[1,:] .= Œ∑[2]\n    component(component(DF, 1, 2), 3)[1,:] .= Œ∑[3]\n\n    f!(component(DF, 2, 1), u, œÉ, œÅ, Œ≤)\n\n    project!(component(DF, 2, 2), Œ≥ * Df!(component(DF, 2, 2), u, œÉ, œÅ, Œ≤) - Derivative(1))\n\n    return DF\nend\nnothing # hide\n\nConsider the fixed-point operator T  X to X defined by\n\nT(x) bydef x - A F(x)\n\nwhere A  X to X is an injective operator corresponding to an approximation of DF(bx)^-1 for some numerical zero bx = (bargamma baru_1 baru_2 baru_3) in X of F.\n\nGiven an initial guess, the numerical zero bx of F may be obtained by Newton's method:\n\nœÉ, œÅ, Œ≤ = 10.0, 28.0, 8/3\n\nK = 60\n\nxÃÑ = zeros(ComplexF64, ParameterSpace() √ó Fourier(K, 1.0)^3)\nxÃÑ[1] = 1.5/(2œÄ) # Œ≥, i.e. approximate inverse of the frequency\ncomponent(component(xÃÑ, 2), 1)[1:2:5] =\n    [-2.9 - 4.3im,\n      1.6 - 1.1im,\n      0.3 + 0.4im]\ncomponent(component(xÃÑ, 2), 2)[1:2:5] =\n    [-1.2 - 5.4im,\n      3.0 + 0.8im,\n     -0.4 + 1.1im]\ncomponent(component(xÃÑ, 2), 3)[0:2:4] =\n    [ 23,\n      3.8 + 4.7im,\n     -1.8 + 0.9im]\ncomponent(component(xÃÑ, 2), 1)[-5:2:-1] .= conj.(component(component(xÃÑ, 2), 1)[5:-2:1])\ncomponent(component(xÃÑ, 2), 2)[-5:2:-1] .= conj.(component(component(xÃÑ, 2), 2)[5:-2:1])\ncomponent(component(xÃÑ, 2), 3)[-4:2:0] .= conj.(component(component(xÃÑ, 2), 3)[4:-2:0])\n\nŒæ = component(xÃÑ, 2)(0)\nŒ∑ = differentiate(component(xÃÑ, 2))(0)\n\nnewton!((F, DF, x) -> (F!(F, x, œÉ, œÅ, Œ≤, Œæ, Œ∑), DF!(DF, x, œÉ, œÅ, Œ≤, Œ∑)), xÃÑ)\n\n# impose that xÃÑ[1] is real and component(xÃÑ, 2) are the coefficients of a real Fourier series\nxÃÑ[1] = real(xÃÑ[1])\nfor i ‚àà 1:3\n    component(component(xÃÑ, 2), i)[0] = real(component(component(xÃÑ, 2), i)[0])\n    component(component(xÃÑ, 2), i)[-K:-1] .= conj.(component(component(xÃÑ, 2), i)[K:-1:1])\nend\n\nLet R  0. Since T in C^2(X X) we may use the second-order Radii Polynomial Theorem such that we need to estimate T(bx) - bx_X, DT(bx)_mathscrB(X X) and sup_x in textcl( B_R(bx) ) D^2T(x)_mathscrB(X mathscrB(X X)).\n\nTo this end, consider the truncation operator\n\n(Pi_K u)_k bydef\nbegincases\nu_k  k le K\n0  k  K\nendcases\nqquad textfor all  u in ell^1_nu mathbbZ\n\nUsing the same symbol, this projection extends naturally to (ell^1_nu mathbbZ)^3 and X by acting on each component as follows Pi_K u bydef (Pi_K u_1 Pi_K u_2 Pi_K u_3), for all u = (u_1 u_2 u_3) in (ell^1_nu mathbbZ)^3, and Pi_K x bydef (gamma Pi_K u_1 Pi_K u_2 Pi_K u_3), for all x = (gamma u_1 u_2 u_3) in X. For each of the Banach spaces ell^1_nu mathbbZ (ell^1_nu mathbbZ)^3 X, we define the complementary operator Pi_infty(K) bydef I - Pi_K.\n\nThus, denoting baru = (baru_1 baru_2 baru_3), we have\n\nbeginaligned\nT(bx) - bx_X le\nPi_K A Pi_K F(bx)_X + fracbargamman+1 Pi_infty(K) f(baru sigma rho beta)_(ell^1_nu mathbbZ)^3\nDT(bx)_mathscrB(X X) le\nPi_K A Pi_K DF(bx) Pi_2K - Pi_K_mathscrB(X X) + frac1n+1 maxBig( Pi_infty(K) f(baru sigma rho beta)_(ell^1_nu mathbbZ)^3\nqquad bargamma maxleft(sigma + rho-baru_3_ell^1_nu mathbbZ + baru_2_ell^1_nu mathbbZ sigma + 1 + baru_1_ell^1_nu mathbbZ baru_1_ell^1_nu mathbbZ + betaright) Big)\nsup_x in textcl( B_R(bx) ) D^2T(x)_mathscrB(X mathscrB(X X)) le\nleft(Pi_K A Pi_K_mathscrB(X X) + frac1n+1right) maxBig( 2 (bargamma + R)\nqquad maxleft(sigma + rho-baru_3_ell^1_nu mathbbZ + baru_2_ell^1_nu mathbbZ + 2R sigma + 1 + baru_1_ell^1_nu mathbbZ + R baru_1_ell^1_nu mathbbZ + R + betaright) Big)\nendaligned\n\nThe computer-assisted proof may be implemented as follows:\n\nŒΩ = interval(1.05)\nX_F = ‚Ñì¬π(GeometricWeight(ŒΩ))\nX_F¬≥ = NormedCartesianSpace(X_F, ‚Ñì¬π())\nX = NormedCartesianSpace((‚Ñì¬π(), X_F¬≥), ‚Ñì¬π())\nR = 1e-10\n\nœÉ_interval, œÅ_interval, Œ≤_interval = interval(10), interval(28), interval(8)/interval(3)\n\nxÃÑ_interval = Sequence(ParameterSpace() √ó Fourier(K, interval(1))^3, interval.(coefficients(xÃÑ)))\nŒ≥ÃÑ_interval = real(xÃÑ_interval[1])\nuÃÑ_interval = component(xÃÑ_interval, 2)\n\nŒæ_interval = interval.(Œæ)\nŒ∑_interval = interval.(Œ∑)\n\nF_interval = zeros(eltype(xÃÑ_interval), ParameterSpace() √ó Fourier(2K, interval(1))^3)\nF!(F_interval, xÃÑ_interval, œÉ_interval, œÅ_interval, Œ≤_interval, Œæ_interval, Œ∑_interval)\n\ntail_Œ≥ÃÑf_interval = copy(component(F_interval, 2))\nfor i ‚àà 1:3\n    component(tail_Œ≥ÃÑf_interval, i)[-K:K] .= interval(0)\nend\n\nDF_interval = zeros(eltype(xÃÑ_interval), space(F_interval), space(xÃÑ_interval))\nDF!(DF_interval, xÃÑ_interval, œÉ_interval, œÅ_interval, Œ≤_interval, Œ∑_interval)\n\nA = interval.(inv(mid.(project(DF_interval, space(xÃÑ_interval), space(xÃÑ_interval)))))\nbound_tail_A = inv(interval(K+1))\n\n# computation of the bounds\n\nY = norm(A * F_interval, X) + bound_tail_A * norm(tail_Œ≥ÃÑf_interval, X_F¬≥)\n\nopnorm_Df = max(œÉ_interval + norm(œÅ_interval-component(uÃÑ_interval, 3), X_F) + norm(component(uÃÑ_interval, 2), X_F),\n                œÉ_interval + 1 + norm(component(uÃÑ_interval, 1), X_F),\n                norm(component(uÃÑ_interval, 1), X_F) + Œ≤_interval)\n\nZ‚ÇÅ = opnorm(A * DF_interval - UniformScaling(interval(1)), X) +\n    bound_tail_A * max(norm(tail_Œ≥ÃÑf_interval / Œ≥ÃÑ_interval, X_F¬≥), Œ≥ÃÑ_interval * opnorm_Df)\n\nZ‚ÇÇ = (opnorm(A, X) + bound_tail_A) * max(2 * (Œ≥ÃÑ_interval + R),\n    max(œÉ_interval + norm(œÅ_interval - component(uÃÑ_interval, 3), X_F) + R + norm(component(uÃÑ_interval, 2), X_F) + R,\n        œÉ_interval + 1 + norm(component(uÃÑ_interval, 1), X_F) + R,\n        norm(component(uÃÑ_interval, 1), X_F) + R + Œ≤_interval))\n\nsetdisplay(:full)\n\ninterval_of_existence(Y, Z‚ÇÅ, Z‚ÇÇ, R)\n\nThe following animation[2] shows the numerical approximation of the proven periodic orbit (blue line) and the equilibria (red markers).\n\n[2]: S. Danisch and J. Krumbiegel, Makie.jl: Flexible high-performance data visualization for Julia, Journal of Open Source Software, 6 (2021), 3349.\n\n<video width=\"800\" height=\"400\" controls autoplay loop>\n  <source src=\"../lorenz_po.mp4\" type=\"video/mp4\">\n</video>","category":"section"},{"location":"examples/infinite_dimensional_proofs/ode/logistic_ivp/#Initial-value-problem-of-the-logistic-equation","page":"Initial value problem of the logistic equation","title":"Initial value problem of the logistic equation","text":"In this example, we will prove the existence of a solution of the logistic equation\n\nbegincases\ndisplaystyle fracddt u(t) = f(u(t)) bydef u(t)(1 - u(t))\nu(0) = 12\nendcases\n\nLet nu  0,\n\nell^1_nu mathbbN bydef left  x_alpha _alpha ge 0 in mathbbR^mathbbN     x _ell^1_nu mathbbN bydef sum_alpha ge 0 x_alpha nu^alpha  +infty right\n\nand *  ell^1_nu mathbbN times ell^1_nu mathbbN to ell^1_nu mathbbN be the Cauchy product given by\n\nx * y bydef left sum_beta = 0^alpha x_alpha - beta y_beta right_alpha ge 0 qquad textfor all  x y in ell^1_nu mathbbN\n\nFor any sequence x in ell^1_nu mathbbN, the Taylor series sum_alpha ge 0 x_alpha t^alpha defines an analytic function in C^omega(-nu nu mathbbR); while the Cauchy product * corresponds to the product of Taylor series in sequence space.\n\nThe Banach space ell^1_nu mathbbN is a suitable space to represent a solution of the logistic equation. Indeed, it is a standard result from ODE theory that analytic vector fields yield analytic solutions.[1]\n\n[1]: A. Hungria, J.-P. Lessard and J. D. Mireles James, Rigorous numerics for analytic solutions of differential equations: the radii polynomial approach, Mathematics of Computation, 85 (2016), 1427-1459.\n\nIt follows that the sequence of coefficients of a Taylor series solving the initial value problem is a zero of the mapping F  ell^1_nu mathbbN to ell^1_nu mathbbN given component-wise by\n\n( F(x) )_alpha bydef\nbegincases\nx_0 - 12  alpha = 0\nalpha x_alpha - (x*(1 - x))_alpha-1  alpha ge 1\nendcases\n\nThe mapping F and its Fr√©chet derivative, denoted DF, may be implemented as follows:\n\nusing RadiiPolynomial\n\nfunction F!(F, x)\n    F[0] = x[0] - 0.5\n\n    v = differentiate(x) - x*(1 - x)\n    for Œ± ‚àà 1:order(F)\n        F[Œ±] = v[Œ±-1]\n    end\n\n    return F\nend\n\nfunction DF!(DF, x)\n    DF .= 0\n\n    DF[0,0] = 1\n\n    DF[1:end,:] .= Derivative(1) - project(Multiplication(1 - 2x), domain(DF), Taylor(order(codomain(DF))-1))\n\n    return DF\nend\nnothing # hide\n\nConsider the fixed-point operator T  ell^1_nu mathbbN to ell^1_nu mathbbN defined by\n\nT(x) bydef x - A F(x)\n\nwhere A  ell^1_nu mathbbN to ell^1_nu mathbbN is an injective operator corresponding to an approximation of DF(bx)^-1 for some numerical zero bx in ell^1_nu mathbbN of F.\n\nGiven an initial guess, the numerical zero bx of F may be obtained by Newton's method:\n\nn = 27\n\nxÃÑ = Sequence(Taylor(n), zeros(n+1))\n\nxÃÑ, success = newton!((F, DF, x) -> (F!(F, x), DF!(DF, x)), xÃÑ)\nnothing # hide\n\nLet R  0. Since T in C^2(ell^1_nu mathbbN ell^1_nu mathbbN) we may use the second-order Radii Polynomial Theorem such that we need to estimate T(bx) - bx_ell^1_nu mathbbN, DT(bx)_mathscrB(ell^1_nu mathbbN ell^1_nu mathbbN) and sup_x in textcl( B_R(bx) ) D^2T(x)_mathscrB(ell^1_nu mathbbN mathscrB(ell^1_nu mathbbN ell^1_nu mathbbN)).\n\nTo this end, consider the truncation operator\n\n(Pi_n x)_alpha bydef\nbegincases x_alpha  alpha le n\n0  alpha  n\nendcases qquad textfor all  x in ell^1_nu mathbbN\n\nas well as the complementary operator Pi_infty(n) bydef I - Pi_n.\n\nThus, we have\n\nbeginaligned\nT(bx) - bx_ell^1_nu mathbbN le Pi_n A Pi_n F(bx)_ell^1_nu mathbbN + frac1n+1 Pi_infty(n) F(bx)_ell^1_nu mathbbN\nDT(bx)_mathscrB(ell^1_nu mathbbN ell^1_nu mathbbN) le maxleft(Pi_n A Pi_n DF(bx) Pi_n - Pi_n_mathscrB(ell^1_nu mathbbN ell^1_nu mathbbN) fracnun+1 2bx - 1_ell^1_nu mathbbNright)\nsup_x in textcl( B_R(bx) ) D^2T(x)_mathscrB(ell^1_nu mathbbN mathscrB(ell^1_nu mathbbN ell^1_nu mathbbN)) le 2 nu left( Pi_n A Pi_n_mathscrB(ell^1_nu mathbbN ell^1_nu mathbbN) + frac1n+1 right)\nendaligned\n\nIn particular, from the latter estimate, we may freely choose R = infty.\n\nThe computer-assisted proof may be implemented as follows:\n\nŒΩ = interval(2)\nX = ‚Ñì¬π(GeometricWeight(ŒΩ))\nR = Inf\n\nxÃÑ_interval = interval.(xÃÑ)\n\nF_interval = zeros(eltype(xÃÑ_interval), Taylor(2n+1))\nF!(F_interval, xÃÑ_interval)\n\ntail_F_interval = copy(F_interval)\ntail_F_interval[0:n] .= interval(0)\n\nDF_interval = zeros(eltype(xÃÑ_interval), Taylor(n), Taylor(n))\nDF!(DF_interval, xÃÑ_interval)\n\nA = interval.(inv(mid.(DF_interval)))\nbound_tail_A = inv(interval(n+1))\n\n# computation of the bounds\n\nY = norm(A * F_interval, X) + bound_tail_A * norm(tail_F_interval, X)\n\nZ‚ÇÅ = max(opnorm(A * DF_interval - UniformScaling(interval(1)), X), bound_tail_A * ŒΩ * norm(interval(2) * xÃÑ_interval - interval(1), X))\n\nZ‚ÇÇ = (opnorm(A, X) + bound_tail_A) * ŒΩ * interval(2)\n\nsetdisplay(:full)\n\ninterval_of_existence(Y, Z‚ÇÅ, Z‚ÇÇ, R)\n\nThe following figure[2] shows the numerical approximation of the proven solution in the interval -2 2 along with the theoretical solution t mapsto (1 + e^-t)^-1.\n\n[2]: S. Danisch and J. Krumbiegel, Makie.jl: Flexible high-performance data visualization for Julia, Journal of Open Source Software, 6 (2021), 3349.\n\n(Image: )","category":"section"},{"location":"manual/norms/#Norms","page":"Norms","title":"Norms","text":"The choice of the Banach space to apply the Radii Polynomial Theorem (cf. Section Radii polynomial approach) is integral to the success of the computer-assisted proof. In practice, it is useful to tune the Banach space on the fly to adjust the norm estimates.\n\nAccordingly, the spaces introduced in Section Vector spaces are not normed a priori. The norm of a Sequence or a LinearOperator is obtained via the functions norm and opnorm respectively; in both cases, one must specify a BanachSpace.\n\nBanachSpace\n‚îú‚îÄ NormedCartesianSpace\n‚îú‚îÄ Ell1\n‚îú‚îÄ Ell2\n‚îî‚îÄ EllInf","category":"section"},{"location":"manual/norms/#\\ell1,-\\ell2-and-\\ell\\infty","page":"Norms","title":"ell^1, ell^2 and ell^infty","text":"Let mathscrI be a set of indices such that mathscrI subset mathbbZ^d for some d in mathbbN. Consider the weighted ell^1 ell^2 ell^infty spaces (cf. ell^p spaces) defined by\n\nbeginaligned\nell^1_w bydef left a in mathbbC^mathscrI     a _ell^1_w bydef sum_alpha in mathscrI a_alpha w(alpha)  infty right \nell^2_w bydef left a in mathbbC^mathscrI     a _ell^2_w bydef sqrtsum_alpha in mathscrI a_alpha^2 w(alpha)  infty right \nell^infty_w bydef left a in mathbbC^mathscrI     a _ell^infty_w bydef sup_alpha in mathscrI  a_alpha  w(alpha)  infty right\nendaligned\n\nwhere w  mathscrI to (0 infty) is a weight function.\n\nThe Banach spaces Ell1, Ell2 and EllInf wraps one or multiple Weight.\n\nWeight\n‚îú‚îÄ AlgebraicWeight\n‚îú‚îÄ BesselWeight\n‚îú‚îÄ GeometricWeight\n‚îî‚îÄ IdentityWeight\n\nGiven a set of indices mathscrI^prime subset mathbbZ:\n\nan AlgebraicWeight of rate s ge 0 is defined by w(alpha) bydef (1 + alpha)^s for all alpha in mathscrI^prime.\na BesselWeight of rate s ge 0 is defined by w(alpha) bydef (1 + alpha^2)^s for all alpha in mathscrI^prime. This weight is specific to Ell2 and Fourier as it describes the Sobolev space H^s.\na GeometricWeight of rate nu ge 1 is defined by w(alpha) bydef nu^alpha for all alpha in mathscrI^prime.\nan IdentityWeight is defined by w(alpha) bydef 1 for all alpha in mathscrI^prime. This is the default weight for Ell1, Ell2 and EllInf.\n\na = Sequence(Taylor(2), [1.0, 1.0, 1.0]); # 1 + x + x^2\nnorm(a, Ell1(AlgebraicWeight(1.0)))\nb = Sequence(Fourier(1, 1.0), [0.5, 0.0, 0.5]); # cos(x)\nnorm(b, Ell2(BesselWeight(2.0)))\nc = Sequence(Chebyshev(2), [1.0, 0.5, 0.5]); # 1 + 2(x/2 + (2x^2 - 1)/2)\nnorm(c, EllInf()) # EllInf() == EllInf(IdentityWeight())\n\nNote that ‚Ñì¬π (\\ell<tab>\\^1<tab>), ‚Ñì¬≤ (\\ell<tab>\\^2<tab>) and ‚Ñì‚àû (\\ell<tab>\\infty<tab>) are the respective unicode aliases of Ell1, Ell2 and EllInf.\n\nIn the context of a d-dimensional TensorSpace, one prescribes weights w_1 dots w_d for each dimension. The weight is defined by w(alpha) = w_1(alpha_1) times ldots times w_d(alpha_d) for all alpha = (alpha_1 dots alpha_d) in mathscrI^primeprime where mathscrI^primeprime subset mathbbZ^d is the appropriate set of indices.\n\na = ones(Taylor(2) ‚äó Fourier(2, 1.0) ‚äó Chebyshev(2));\nnorm(a, Ell1((AlgebraicWeight(1.0), GeometricWeight(2.0), IdentityWeight())))\n\nHowever, the d-dimensional version of BesselWeight is defined by w(alpha) bydef (1 + alpha_1^2 + ldots + alpha_d^2)^s for all alpha = (alpha_1 dots alpha_d) in mathbbZ^d. Only one BesselWeight is required for every Fourier space composing the TensorSpace.\n\na = ones(Fourier(2, 1.0) ‚äó Fourier(3, 1.0));\nnorm(a, Ell2(BesselWeight(2.0)))","category":"section"},{"location":"manual/norms/#Normed-cartesian-space","page":"Norms","title":"Normed cartesian space","text":"For the norm of a CartesianSpace, one may use a NormedCartesianSpace to either:\n\nuse the same BanachSpace for each space.\nuse a different BanachSpace for each space.\n\na = Sequence(Taylor(1)^2, [1.0, 2.0, 3.0, 4.0]);\nnorm(a, NormedCartesianSpace(‚Ñì¬π(), ‚Ñì‚àû()))\nnorm(a, NormedCartesianSpace((‚Ñì¬π(), ‚Ñì¬≤()), ‚Ñì‚àû()))","category":"section"},{"location":"manual/norms/#API","page":"Norms","title":"API","text":"","category":"section"},{"location":"manual/norms/#LinearAlgebra.norm","page":"Norms","title":"LinearAlgebra.norm","text":"norm(a::AbstractSequence, p::Real=Inf)\n\nCompute the p-norm of a. Only p equal to 1, 2 or Inf is supported.\n\nThis is equivalent to:\n\nnorm(a, Ell1(IdentityWeight())) if p == 1\nnorm(a, Ell2(IdentityWeight())) if p == 2\nnorm(a, EllInf(IdentityWeight())) if p == Inf\n\nSee also: norm(::Sequence, ::BanachSpace).\n\n\n\n\n\n","category":"function"},{"location":"manual/norms/#LinearAlgebra.norm-Tuple{Sequence, BanachSpace}","page":"Norms","title":"LinearAlgebra.norm","text":"norm(a::Sequence, X::BanachSpace)\n\nCompute the norm of a by interpreting space(a) as X.\n\nSee also: norm(::Sequence, ::Real=Inf).\n\n\n\n\n\n","category":"method"},{"location":"manual/norms/#LinearAlgebra.opnorm","page":"Norms","title":"LinearAlgebra.opnorm","text":"opnorm(A::LinearOperator, p::Real=Inf)\n\nCompute the operator norm of A induced by the p-norm. Only p equal to 1, 2 or Inf is supported.\n\nThis is equivalent to:\n\nopnorm(A, Ell1(IdentityWeight())) if p == 1\nopnorm(A, Ell2(IdentityWeight())) if p == 2\nopnorm(A, EllInf(IdentityWeight())) if p == Inf\n\nSee also: opnorm(::LinearOperator, ::BanachSpace), opnorm(::LinearOperator, ::BanachSpace, ::BanachSpace) and opnorm(::LinearOperator{<:VectorSpace,ParameterSpace}, ::BanachSpace).\n\n\n\n\n\n","category":"function"},{"location":"manual/norms/#LinearAlgebra.opnorm-Tuple{LinearOperator, BanachSpace, BanachSpace}","page":"Norms","title":"LinearAlgebra.opnorm","text":"opnorm(A::LinearOperator, X::BanachSpace, Y::BanachSpace)\n\nCompute the operator norm of A where X is the Banach space corresponding to domain(A) and Y the Banach space corresponding to codomain(A).\n\nSee also: opnorm(::LinearOperator, ::Real=Inf), opnorm(::LinearOperator, ::BanachSpace) and opnorm(::LinearOperator{<:VectorSpace,ParameterSpace}, ::BanachSpace).\n\n\n\n\n\n","category":"method"},{"location":"manual/norms/#LinearAlgebra.opnorm-Tuple{LinearOperator, BanachSpace}","page":"Norms","title":"LinearAlgebra.opnorm","text":"opnorm(A::LinearOperator, X::BanachSpace)\n\nCompute the operator norm of A where X is the Banach space corresponding to both domain(A) and codomain(A).\n\nSee also: opnorm(::LinearOperator, ::Real=Inf), opnorm(::LinearOperator, ::BanachSpace, ::BanachSpace) and opnorm(::LinearOperator{<:VectorSpace,ParameterSpace}, ::BanachSpace).\n\n\n\n\n\n","category":"method"},{"location":"manual/norms/#LinearAlgebra.opnorm-Tuple{LinearOperator{<:VectorSpace, ParameterSpace}, BanachSpace}","page":"Norms","title":"LinearAlgebra.opnorm","text":"opnorm(A::LinearOperator{<:VectorSpace,ParameterSpace}, X::BanachSpace)\n\nCompute the operator norm of A where X is the Banach space corresponding to domain(A).\n\nSee also: opnorm(::LinearOperator, ::Real=Inf), opnorm(::LinearOperator, ::BanachSpace, ::BanachSpace) and opnorm(::LinearOperator, ::BanachSpace).\n\n\n\n\n\n","category":"method"},{"location":"examples/infinite_dimensional_proofs/dde/ikeda_W_u/#Unstable-manifolds-of-equilibria-of-the-cubic-Ikeda-equation","page":"Unstable manifolds of equilibria of the cubic Ikeda equation","title":"Unstable manifolds of equilibria of the cubic Ikeda equation","text":"In this example, we will rigorously compute the unstable manifolds of the equilibria for the cubic Ikeda equation\n\nfracddt u(t) = f(u(t) u(t-tau)) bydef u(t-tau) - u(t-tau)^3\n\nThe linearization at some equilibrium c in mathbbR yields\n\nfracddt v(t) = (1 - 3c^2) v(t-tau)\n\nThe right-hand side of the above equation is an infinite dimensional endomorphism acting on C(-tau 0 mathbbR). Its compactness guarantees that the spectrum is comprised of eigenvalues accumulating at 0; in particular, there are finitely many eigenvalues whose real parts are strictly positive. As a matter of fact, an eigenvector xi in C(-tau 0 mathbbC) associated with an eigenvalue lambda in mathbbC is given by xi(s) = e^s lambda xi(0), for all s in -tau 0 and xi(0) neq 0, such that\n\nPsi(lambda) bydef lambda - (1 - 3c^2) e^-tau lambda = 0\n\nThe characteristic function Psi and its derivative with respect to lambda, denoted DPsi, may be implemented as follows:\n\nŒ®(Œª, c, œÑ) = Œª - (1 - 3c^2) * exp(-œÑ*Œª)\n\nDŒ®(Œª, c, œÑ) = 1 + œÑ * (1 - 3c^2) * exp(-œÑ*Œª)\nnothing # hide\n\nFor the cubic Ikeda equation, the equilibria are 0, 1 or -1. For the equilibrium c = 0, there is a unique real unstable eigenvalue. While for the equilibria c = 1 and c = -1, there are two complex conjugate unstable eigenvalues.\n\nFor the equilibrium c = 0, we may use the first-order Radii Polynomial Theorem to rigorously compute the unstable eigenvalue:\n\nusing RadiiPolynomial\n\nŒªÃÑ‚ÇÄ, success = newton(Œª -> (Œ®(Œª, 0.0, 1.59), DŒ®(Œª, 0.0, 1.59)), 0.5)\n\nR = 1e-14\n\nœÑ = I\"1.59\"\n\nY = abs(Œ®(interval(ŒªÃÑ‚ÇÄ), interval(0), œÑ))\nZ‚ÇÅ = abs(1 - interval(DŒ®(ŒªÃÑ‚ÇÄ, 0, mid(œÑ))) \\ DŒ®(interval(ŒªÃÑ‚ÇÄ, R; format = :midpoint), interval(0), œÑ))\nœµ‚ÇÄ = inf(interval_of_existence(Y, Z‚ÇÅ, R)[1])\nŒª‚ÇÄ = interval(ŒªÃÑ‚ÇÄ, œµ‚ÇÄ; format = :midpoint)\n\nsetdisplay(:full)\n\nŒª‚ÇÄ\n\nSimilarly, for the equilibria c = 1 and c = -1, we may use the same strategy to compute one of the two complex conjugate unstable eigenvalues:\n\nŒªÃÑ‚ÇÅ, success = newton(Œª -> (Œ®(Œª, 1.0, 1.59), DŒ®(Œª, 1.0, 1.59)), 0.3+1.0im)\n\nY = abs(Œ®(interval(ŒªÃÑ‚ÇÅ), interval(1), œÑ))\nZ‚ÇÅ = abs(1 - interval(DŒ®(ŒªÃÑ‚ÇÅ, 1, œÑ)) \\ DŒ®(interval(ŒªÃÑ‚ÇÅ, R; format = :midpoint), interval(1), œÑ))\nœµ‚ÇÅ = inf(interval_of_existence(Y, Z‚ÇÅ, R)[1])\nŒª‚ÇÅ = interval(ŒªÃÑ‚ÇÅ, œµ‚ÇÅ; format = :midpoint)\n\nsetdisplay(:full)\n\nŒª‚ÇÅ\n\nLet lambda_1 dots lambda_d be the unstable eigenvalues and xi_1 dots xi_d the respective eigenvectors. Denote by Lambda  mathbbC^d to mathbbC^d the diagonal matrix such that Lambda_ii bydef lambda_i; also, denote by Xi  mathbbC^d to C(-tau 0 mathbbC) the matrix whose i-th column is the eigenvector xi_i.\n\nLet\n\nX bydef left  x_alpha _alpha_1 + ldots + alpha_d ge 0 in mathbbC^(mathbbN cup 0)^d     x _X bydef sum_alpha_1 + ldots + alpha_d ge 0 x_alpha  +infty right\n\nand *  X times X to X be the Cauchy product given by\n\nx * y bydef left sum_beta_1 + ldots + beta_d ge 0^alpha x_alpha - beta y_beta right_alpha_1 + ldots + alpha_d ge 0 qquad textfor all  x y in X\n\nFor any sequence x in X, the Taylor series sum_alpha_1 + ldots + alpha_d ge 0 x_alpha sigma^alpha defines an analytic function in C^omega(mathbbD^d mathbbC) where mathbbD bydef  z in mathbbC    z le 1 ; while the Cauchy product * corresponds to the product of Taylor series in sequence space.\n\nThe Banach space X is a suitable space to represent a parameterization of the unstable manifold. Indeed, it is a standard result from DDE theory that analytic vector fields yield analytic unstable manifolds of equilibria. In the context of this example, it holds that the unstable manifold is parameterized by an analytic function P  mathbbC^d to C(-tau 0 mathbbC) satisfying fracdds P(sigma)(s) = DP(sigma) Lambda sigma(s) along with DP(sigma) Lambda sigma(0) = f(P (sigma)(0) P(sigma)(-tau)).[1]\n\n[1]: O. H√©not, J.-P. Lessard and J. D. Mireles James, Parameterization of unstable manifolds for DDEs: formal series solutions and validated error bounds, Journal of Dynamics and Differential Equations, 34 (2022), 1285-1324.\n\nIn terms of the Taylor coefficients, the previous equalities yield\n\nP(sigma)(s) = sum_alpha_1 + ldots + alpha_d ge 0 tx_alpha e^s (alpha_1 lambda_1 + ldots + alpha_d lambda_d) sigma^alpha\n\nwhere tx in X is given component-wise by\n\ntx_alpha bydef\nbegincases\nc  alpha_1 = ldots = alpha_d = 0\nxi_1  alpha_1 = 1 alpha_2 = ldots = alpha_d = 0\nvdots\nxi_d  alpha_d = 1 alpha_1 = ldots = alpha_d-1 = 0\nPsi(alpha_1 lambda_1 + ldots + alpha_d lambda_d)^-1 left(-e^-tau (alpha_1 lambda_1 + ldots + alpha_d lambda_d) tx * tx * tx_tx_alpha = 0right)_alpha  alpha_1 + ldots + alpha_d ge 2\nendcases\n\nObserve that the unstable manifold of the equilibrium c = -1 is the same as the of the equilibrium c = 1 modulo a change of sign. Thus, we shall only study the unstable manifolds of the equilibria c = 0 and c = 1.\n\nFor the equilibrium c = 0, we may implement the 1-dimensional recurrence relation as follows:\n\nn‚ÇÄ = 85\nxÃÉ‚ÇÄ = zeros(Interval{Float64}, Taylor(n‚ÇÄ))\nxÃÉ‚ÇÄ[1] = interval(5)\nyÃÉ‚ÇÄ = copy(xÃÉ‚ÇÄ)\nyÃÉ‚ÇÄ[1] *= exp(-œÑ * Œª‚ÇÄ)\nfor Œ± ‚àà 2:n‚ÇÄ\n    xÃÉ‚ÇÄ[Œ±] = -Œ®(Œ±*Œª‚ÇÄ, interval(0), œÑ) \\ pow_bar(Sequence(Taylor(Œ±), view(yÃÉ‚ÇÄ, 0:Œ±)), 3)[Œ±]\n    yÃÉ‚ÇÄ[Œ±] = xÃÉ‚ÇÄ[Œ±] * exp(-œÑ * Œ±*Œª‚ÇÄ)\nend\n\nSimilarly, for the equilibrium c = 1, we may implement the 2-dimensional recurrence relation as follows:\n\nn‚ÇÅ = 25\nxÃÉ‚ÇÅ = zeros(Complex{Interval{Float64}}, Taylor(n‚ÇÅ) ‚äó Taylor(n‚ÇÅ))\nxÃÉ‚ÇÅ[(0,0)] = interval(1)\nxÃÉ‚ÇÅ[(1,0)] = xÃÉ‚ÇÅ[(0,1)] = interval(0.35)\nyÃÉ‚ÇÅ = copy(xÃÉ‚ÇÅ)\nyÃÉ‚ÇÅ[(1,0)] *= exp(-œÑ * Œª‚ÇÅ)\nyÃÉ‚ÇÅ[(0,1)] *= exp(-œÑ * conj(Œª‚ÇÅ))\nfor Œ±‚ÇÇ ‚àà 0:n‚ÇÅ, Œ±‚ÇÅ ‚àà 0:n‚ÇÅ-Œ±‚ÇÇ\n    if Œ±‚ÇÅ + Œ±‚ÇÇ ‚â• 2\n        xÃÉ‚ÇÅ[(Œ±‚ÇÅ,Œ±‚ÇÇ)] = -Œ®(Œ±‚ÇÅ*Œª‚ÇÅ + Œ±‚ÇÇ*conj(Œª‚ÇÅ), interval(1), œÑ) \\ pow_bar(Sequence(Taylor(Œ±‚ÇÅ) ‚äó Taylor(Œ±‚ÇÇ), view(yÃÉ‚ÇÅ, (0:Œ±‚ÇÅ, 0:Œ±‚ÇÇ))), 3)[(Œ±‚ÇÅ,Œ±‚ÇÇ)]\n        yÃÉ‚ÇÅ[(Œ±‚ÇÅ,Œ±‚ÇÇ)] = xÃÉ‚ÇÅ[(Œ±‚ÇÅ,Œ±‚ÇÇ)] * exp(-œÑ * (Œ±‚ÇÅ*Œª‚ÇÅ + Œ±‚ÇÇ*conj(Œª‚ÇÅ)))\n    end\nend\n\nConsider the truncation operator\n\n(Pi_n x)_alpha bydef\nbegincases x_alpha  alpha_1 + ldots + alpha_d le n\n0  alpha_1 + ldots + alpha_d  n\nendcases\nqquad textfor all  x in X\n\nas well as the complementary operator Pi_infty(n) bydef I - Pi_n.\n\nGiven that Pi_n tx is a finite sequence of known Taylor coefficients, it follows that the remaining coefficients are a fixed-point of the mapping T  Pi_infty(n) X to Pi_infty(n) X given component-wise by\n\n( T(h) )_alpha bydef\nbegincases\n0  alpha_1 + ldots + alpha_d le n\nPsi(alpha_1 lambda_1 + ldots + alpha_d lambda_d)^-1 left( -e^-tau (alpha_1 lambda_1 + ldots + alpha_d lambda_d) (Pi_n tx +h)*(Pi_n tx +h)*(Pi_n tx +h)_h_alpha = 0 right)_alpha  alpha_1 + ldots + alpha_d  n\nendcases\n\nLet R  0. Since T in C^1(Pi_infty(n) X Pi_infty(n) X) we may use the first-order Radii Polynomial Theorem for which we use the estimates\n\nbeginaligned\nT(0)_X le max_mu in Re(lambda_1) dots Re(lambda_d) frac1(n+1)mu - 1 - 3c^2 e^-œÑ (n+1)mu Pi_infty(n) (Pi_n tildey*Pi_n tildey*Pi_n tildey)_X\nsup_h in textcl( B_R(0) ) DT(h)_mathscrB(X X) le max_mu in Re(lambda_1) dots Re(lambda_d) frac3(n+1)mu - 1 - 3c^2 e^-œÑ (n+1)mu (Pi_n tildey_X + R)^2\nendaligned\n\nwhere tildey bydef left tx_alpha e^-tau (alpha_1 lambda_1 + ldots + alpha_d lambda_d) right_alpha_1 + ldots + alpha_d ge 0.\n\nThe computer-assisted proof for the 1-dimensional unstable manifold of c = 0 may be implemented as follows:\n\nX = ‚Ñì¬π()\n\nR = 1e-12\n\ntail_yÃÉ‚ÇÄ¬≥ = yÃÉ‚ÇÄ ^ 3\ntail_yÃÉ‚ÇÄ¬≥[0:n‚ÇÄ] .= interval(0)\nC‚ÇÄ = interval(n‚ÇÄ+1) * Œª‚ÇÄ - exp(-œÑ * interval(n‚ÇÄ+1) * Œª‚ÇÄ)\n\nY = C‚ÇÄ \\ norm(tail_yÃÉ‚ÇÄ¬≥, X)\n\nZ‚ÇÅ = C‚ÇÄ \\ (interval(3) * (norm(yÃÉ‚ÇÄ, X) + R)^2)\n\n# error bound for the Taylor coefficients of order Œ± > 85 of the parameterization on the domain [-1, 1]\n\nsetdisplay(:full)\n\ninterval_of_existence(Y, Z‚ÇÅ, R)\n\nSimilarly, the computer-assisted proof for the 2-dimensional unstable manifold of c = 1 may be implemented as follows:\n\ntail_yÃÉ‚ÇÅ¬≥ = yÃÉ‚ÇÅ ^ 3\nfor Œ±‚ÇÇ ‚àà 0:n‚ÇÅ, Œ±‚ÇÅ ‚àà 0:n‚ÇÅ-Œ±‚ÇÇ\n    tail_yÃÉ‚ÇÅ¬≥[(Œ±‚ÇÅ,Œ±‚ÇÇ)] = interval(0)\nend\nC‚ÇÅ = interval(n‚ÇÅ+1) * real(Œª‚ÇÅ) - interval(2) * exp(-œÑ * interval(n‚ÇÅ+1) * real(Œª‚ÇÅ))\n\nY = C‚ÇÅ \\ norm(tail_yÃÉ‚ÇÅ¬≥, X)\n\nZ‚ÇÅ = C‚ÇÅ \\ (interval(3) * (norm(yÃÉ‚ÇÅ, X) + R)^2)\n\n# error bound for the Taylor coefficients of order Œ±‚ÇÅ + Œ±‚ÇÇ > 25 of the parameterization on the domain ùîª¬≤\n\nsetdisplay(:full)\n\ninterval_of_existence(Y, Z‚ÇÅ, R)\n\nThe following animation[2] shows:\n\nthe equilibria 0 pm 1 (red markers).\nthe numerical approximation of the parameterization of the 1D unstable manifold of 0: on the domain of the computer-assisted proof -1 1 (green line) and on a larger domain (black line).\nthe numerical approximation of the parameterization of the 2D unstable manifold of pm 1: on the domain of the computer-assisted proof mathbbD^2 (blue surfaces) and on a larger domain (black wireframes).\n\n[2]: S. Danisch and J. Krumbiegel, Makie.jl: Flexible high-performance data visualization for Julia, Journal of Open Source Software, 6 (2021), 3349.\n\n<video width=\"800\" height=\"400\" controls autoplay loop>\n  <source src=\"../ikeda_W_u.mp4\" type=\"video/mp4\">\n</video>","category":"section"},{"location":"examples/finite_dimensional_proofs/spiderweb/#Spiderweb-central-configurations","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"In this example, we will prove the existence and local uniqueness of a central configuration in the N-body problem.\n\nMore precisely, we will look at configurations given by N = n times ell+1 masses located at the intersection points of ell concurrent equidistributed half-lines with n circles and a central mass m_0. The ell masses on the i-th circle are equal to a positive constant m_i and we allow the particular case m_0 = 0. These central configurations are called spiderweb central configurations.[1]\n\n[1]: O. H√©not and C. Rousseau, Spiderweb central configurations, Qualitative Theory of Dynamical Systems, 18 (2019), 1135‚Äì1160.\n\nThe N-body problem consists in describing the positions mathbfr_1(t)dotsmathbfr_N(t) of N masses m_1dotsm_N interacting through Newton's gravitational law:\n\nm_i fracd^2dt^2 mathbfr_i\n=\n-sum_jneq i fracG m_i m_j(mathbfr_i - mathbfr_j) mathbfr_i - mathbfr_j ^3\n=\n-fracpartialpartial mathbfr_i U (mathbfr)\nqquad\nU (mathbfr)\nbydef\n-sum_ij fracG m_i m_jmathbfr_i - mathbfr_j\n\nfor i = 1dotsN, with mathbfr in  (mathbfr_1dotsmathbfr_N) in mathbbR^3N    mathbfr_i neq mathbfr_j   i neq j, where G denotes the gravitational constant.\n\nIn the following, we fix the centre of mass at the origin and scale G = 1. Moreover, due to the symmetries of a spiderweb central configuration, it is sufficient to consider the accelerations of the n bodies on the positive horizontal axis, and the numbers r_1 dots r_n also denote the positions of the masses on this semi-axis.\n\nThe configuration of N bodies is central at some time t^* if fracd^2dt^2mathbfr(t^*) = lambda mathbfr(t^*) for some common lambda. It is easy to see that lambda is a strictly negative value given by lambda = U(mathbfr)I(mathbfr)  0 where I bydef sum_i = 1^N m_i mathbfr_i(mathbfr)^2 is the moment of inertia. Essentially, the value of lambda scales the system and can be chosen arbitrarily.\n\nThen, the original system of ODEs reduces to the following system of equations in mathbbR^n:\n\nlambda r_i\n=\n-sum_k=1^ell-1 fracm_i2^32r_i^2(1 - cos(theta_k))^12 -fracm_0r_i^2 - sum_beginsmallmatrixj=1jneq i endsmallmatrix^n sum_k=0^ell-1 fracm_j(r_i - r_j cos(theta_k))(r_i^2 + r_j^2 - 2 r_i r_j cos(theta_k))^32\n\nfor i = 1 dots n, with theta_k bydef frac2pi kell and r = (r_1dotsr_n) in mathbbR^n.\n\nThus, a spiderweb central configuration is a zero of the mapping F bydef (F_1 dots F_n)  mathbbR^n to mathbbR^n given by\n\nF_i(r) bydef\nlambda r_i + fracm_0r_i^2 + fracm_i2^32r_i^2zeta_ell + sum_beginsmallmatrixj = 1  j neq i endsmallmatrix^n sum_k=0^ell-1 fracm_j(r_i - r_j cos(theta_k))(r_i^2 + r_j^2 - 2 r_i r_j cos(theta_k))^32  qquad i = 1 dots n\n\nwhere zeta_ell bydef sum_k=1^ell-1 (1 - cos(theta_k))^-12.\n\nThe Jacobian matrix is given by\n\nfracpartialpartial r_j F_i(r) =\nbegincases\ndisplaystyle lambda - frac2m_0r_i^3 - fracm_ir_i^3sqrt2zeta_ell\n-sum_beginsmallmatrixj = 1  j neq iendsmallmatrix^n fracm_j2sum_k=0^ell-1\nfrac4r_i^2 + r_j^2 - 8 r_i r_j cos(theta_k) + 3 r_j^2 cos(2theta_k)(r_i^2 + r_j^2 - 2 r_i r_j cos(theta_k))^52  j = i\ndisplaystyle -fracm_j2 sum_k=0^ell-1\nfrac-4(r_i^2 + r_j^2) cos(theta_k) + r_i r_j (7 + cos(2theta_k))(r_i^2 + r_j^2 - 2 r_i r_j cos(theta_k))^52  j neq i\nendcases\n\nThe mapping F and its Jacobian, denoted DF, may be implemented as follows:\n\nfunction F(x, m‚ÇÄ, m, Œª, l)\n    T = eltype(x)\n    n = length(x)\n    œÄ2l‚Åª¬π = 2convert(T, œÄ)/l\n    F_ = Vector{T}(undef, n)\n    for i ‚àà 1:n\n        F_[i] = Œª*x[i] + m‚ÇÄ/x[i]^2\n        for k ‚àà 1:l-1\n            Œ∏‚Çñ = k*œÄ2l‚Åª¬π\n            F_[i] += m[i]/(2x[i]^2 * sqrt(2 - 2cos(Œ∏‚Çñ)))\n        end\n        for j ‚àà 1:n\n            if i ‚â† j\n                for k ‚àà 0:l-1\n                    Œ∏‚Çñ = k*œÄ2l‚Åª¬π\n                    F_[i] += m[j]*(x[i] - x[j]*cos(Œ∏‚Çñ))/sqrt(x[i]^2 + x[j]^2 - 2x[i]*x[j]*cos(Œ∏‚Çñ))^3\n                end\n            end\n        end\n    end\n    return F_\nend\n\nfunction DF(x, m‚ÇÄ, m, Œª, l)\n    T = eltype(x)\n    n = length(x)\n    œÄ2l‚Åª¬π = 2convert(T, œÄ)/l\n    DF_ = zeros(T, n, n)\n    for j ‚àà 1:n, i ‚àà 1:n\n        if i == j\n            DF_[i,i] += Œª - 2m‚ÇÄ/x[i]^3\n            for k ‚àà 1:l-1\n                Œ∏‚Çñ = k*œÄ2l‚Åª¬π\n                DF_[i,i] -= m[i]/(x[i]^3 * sqrt(2 - 2cos(Œ∏‚Çñ)))\n            end\n        else\n            for k ‚àà 0:l-1\n                Œ∏‚Çñ = k*œÄ2l‚Åª¬π\n                DF_[i,i] -= m[j]*(4x[i]^2 + x[j]^2 - 8x[i]*x[j]*cos(Œ∏‚Çñ) + 3x[j]^2*cos(2Œ∏‚Çñ))/(2sqrt(x[i]^2 + x[j]^2 - 2x[i]*x[j]*cos(Œ∏‚Çñ))^5)\n                DF_[i,j] -= m[j]*(-4(x[i]^2 + x[j]^2)*cos(Œ∏‚Çñ) + x[i]*x[j]*(7 + cos(2Œ∏‚Çñ)))/(2sqrt(x[i]^2 + x[j]^2 - 2x[i]*x[j]*cos(Œ∏‚Çñ))^5)\n            end\n        end\n    end\n    return DF_\nend\nnothing # hide\n\nConsider the fixed-point operator T  mathbbR^n to mathbbR^n defined by\n\nT(x) bydef x - A F(x)\n\nwhere A  mathbbR^n to mathbbR^n is the injective operator corresponding to a numerical approximation of DF(x_0)^-1 for some numerical zero x_0 in mathbbR^n of F.\n\nGiven an initial guess, the numerical zero x_0 of F may be obtained by Newton's method:\n\nusing RadiiPolynomial\n\nn = 18 # number of circles\nl = 100 # number of masses per circle\n\nm‚ÇÄ = 0.0 # central mass\nm = fill(1/l, n) # vector of masses\nŒª = -1.0\n\nx‚ÇÄ = collect(range(1.0; stop = 3.0, length = n))\n\nx‚ÇÄ, success = newton(x -> (F(x, m‚ÇÄ, m, Œª, l), DF(x, m‚ÇÄ, m, Œª, l)), x‚ÇÄ)\nnothing # hide\n\nLet R  0. According to the first-order Radii Polynomial Theorem (cf. Section Radii polynomial approach), we need to estimate T(x_0) - x_0_infty and sup_x in textcl( B_R(x_0) ) DT(x)_infty which can be readily computed with interval arithmetic.\n\nThe computer-assisted proof may be implemented as follows:\n\nR = 1e-12\n\nm‚ÇÄ_interval = interval(0.0)\nm_interval = fill(inv(interval(l)), n)\nŒª_interval = interval(-1.0)\n\nx‚ÇÄ_interval = interval.(x‚ÇÄ)\nx‚ÇÄR_interval = interval.(x‚ÇÄ_interval, R; format = :midpoint)\n\nF_interval = F(x‚ÇÄ_interval, m‚ÇÄ_interval, m_interval, Œª_interval, l)\nDF_interval = DF(x‚ÇÄR_interval, m‚ÇÄ_interval, m_interval, Œª_interval, l)\n\nA = inv(mid.(DF_interval))\n\nY = norm(Sequence(A * F_interval), Inf)\n\nZ‚ÇÅ = opnorm(LinearOperator(A * DF_interval - I), Inf)\n\nsetdisplay(:full)\n\ninterval_of_existence(Y, Z‚ÇÅ, R)\n\nThe following animation[2] shows the numerical approximation of the proven spiderweb central configuration for some given initial velocity.\n\n[2]: S. Danisch and J. Krumbiegel, Makie.jl: Flexible high-performance data visualization for Julia, Journal of Open Source Software, 6 (2021), 3349.\n\n<video width=\"800\" height=\"400\" controls autoplay loop>\n  <source src=\"../spiderweb.mp4\" type=\"video/mp4\">\n</video>","category":"section"},{"location":"manual/sequences/#Sequences","page":"Sequences","title":"Sequences","text":"A Sequence is a structure representing a sequence in a prescribed VectorSpace. More precisely, a Sequence is comprised of the two fields space::VectorSpace and coefficients::AbstractVector with matching dimension and length.\n\na = Sequence(Taylor(1), [1, 2])\n\nThe two fields space and coefficients are accessible via the respective functions of the same name.\n\nspace(a)\ncoefficients(a)\n\nFor convenience, the methods zeros, ones, fill and fill! are available:\n\ns = Taylor(1)\nzeros(s)\nones(s)\nfill(2, s)\nfill!(zeros(s), 2)\n\nThe coefficients of a Sequence are indexed according to the indices of the space (as given by indices).\n\na[0:1] # indices(space(a))\n\nWhen the space of a Sequence is a CartesianSpace, its coefficients are given as the concatenation of the coefficients associated with each space. The function component extracts a Sequence composing the cartesian space.\n\nb = Sequence(ParameterSpace() √ó Taylor(1)^2, [1, 2, 3, 4, 5])\nb[1:5] # indices(space(b))\ncomponent(b, 1) # extract the sequence associated with the space ParameterSpace()\ncomponent(b, 2) # extract the sequence associated with the space Taylor(1)^2\ncomponent(component(b, 2), 1)\ncomponent(component(b, 2), 2)\n\nSimilarly, the function eachcomponent returns a Generator whose iterates yield each Sequence composing the cartesian space.","category":"section"},{"location":"manual/sequences/#Arithmetic","page":"Sequences","title":"Arithmetic","text":"The addition and subtraction operations are implemented as the + and - functions respectively.\n\nc = Sequence(Taylor(1), [0, 1])\nd = Sequence(Taylor(2), [1, 2, 1])\nc + d\nc - d\n\nThe discrete convolution between sequences whose spaces are a SequenceSpace is implemented as the *(::Sequence{<:SequenceSpace}, ::Sequence{<:SequenceSpace}), mul!(::Sequence{<:SequenceSpace}, ::Sequence{<:SequenceSpace}, ::Sequence{<:SequenceSpace}, ::Number, ::Number) and ^(::Sequence{<:SequenceSpace}, ::Int) functions. Their bar counterparts mul_bar (unicode alias *\\bar<tab>) and pow_bar (unicode alias ^\\bar<tab>) give the result projected in the smallest compatible space between the operands; in general, mul_bar is not associative.\n\nc * d\nc ^ 3\nmul_bar(c, d) # project(c * d, Taylor(1))\npow_bar(c, 3) # project(c ^ 3, Taylor(1))\n\nTo improve performance, the FFT algorithm may be used to compute discrete convolutions via the Convolution Theorem. However, the performance gain is tempered with the loss of accuracy which may stop the decay of the coefficients. To circumvent machine precision limitations, the banach_rounding! method enclose rigorously each term of the convolution beyond a prescribed order.[1]\n\n[1]: J.-P. Lessard, Computing discrete convolutions with verified accuracy via Banach algebras and the FFT, Applications of Mathematics, 63 (2018), 219-235.\n\nx = Sequence(Taylor(3), interval.([inv(10_000.0 ^ i) for i ‚àà 0:3]))\nRadiiPolynomial.set_conv_algorithm(:fft)\nx¬≥ = x ^ 3\nRadiiPolynomial.set_conv_algorithm(:sum) # default algorithm\nx¬≥ = x ^ 3 # only rounding error","category":"section"},{"location":"manual/sequences/#API","page":"Sequences","title":"API","text":"","category":"section"},{"location":"manual/vector_spaces/#vector_spaces","page":"Vector spaces","title":"Vector spaces","text":"RadiiPolynomial defines a variety of vector spaces to represent the Banach space on which one applies the Radii Polynomial Theorem.\n\nAll spaces mentioned below are a subtype of the abstract type VectorSpace.\n\nVectorSpace\n‚îú‚îÄ CartesianSpace\n‚îÇ  ‚îú‚îÄ CartesianPower\n‚îÇ  ‚îî‚îÄ CartesianProduct\n‚îú‚îÄ ParameterSpace\n‚îî‚îÄ SequenceSpace\n   ‚îú‚îÄ BaseSpace\n   ‚îÇ  ‚îú‚îÄ Chebyshev\n   ‚îÇ  ‚îú‚îÄ Fourier\n   ‚îÇ  ‚îî‚îÄ Taylor\n   ‚îî‚îÄ TensorSpace","category":"section"},{"location":"manual/vector_spaces/#Parameter-space","page":"Vector spaces","title":"Parameter space","text":"A ParameterSpace represents the commutative field of a parameter. This is the standard space to use for an unfolding parameter.\n\nùí´ = ParameterSpace()\ndimension(ùí´)\nindices(ùí´)","category":"section"},{"location":"manual/vector_spaces/#Sequence-space","page":"Vector spaces","title":"Sequence space","text":"SequenceSpace is the abstract type for all sequence spaces.\n\nSequenceSpace\n‚îú‚îÄ BaseSpace\n‚îÇ  ‚îú‚îÄ Chebyshev\n‚îÇ  ‚îú‚îÄ Fourier\n‚îÇ  ‚îî‚îÄ Taylor\n‚îî‚îÄ TensorSpace","category":"section"},{"location":"manual/vector_spaces/#BaseSpace","page":"Vector spaces","title":"BaseSpace","text":"BaseSpace is the abstract type for all sequence spaces that are not a TensorSpace but can be interlaced to form one.\n\nBaseSpace\n‚îú‚îÄ Chebyshev\n‚îú‚îÄ Fourier\n‚îî‚îÄ Taylor","category":"section"},{"location":"manual/vector_spaces/#Taylor","page":"Vector spaces","title":"Taylor","text":"For a given order n, a Taylor sequence space is the span of phi_0 dots phi_n where phi_k(t) bydef t^k for k = 0 dots n and t in -nu nu for some appropriate nu  0.\n\nùíØ = Taylor(1)\norder(ùíØ)\ndimension(ùíØ)\nindices(ùíØ)","category":"section"},{"location":"manual/vector_spaces/#Fourier","page":"Vector spaces","title":"Fourier","text":"For a given order n and frequency omega, a Fourier sequence space is the span of phi_-n dots phi_n where phi_k(t) bydef e^i omega k t for k = -n dots n and t in mathbbR2piomega^-1mathbbZ.\n\n‚Ñ± = Fourier(1, 1.0)\norder(‚Ñ±)\nfrequency(‚Ñ±)\ndimension(‚Ñ±)\nindices(‚Ñ±)","category":"section"},{"location":"manual/vector_spaces/#Chebyshev","page":"Vector spaces","title":"Chebyshev","text":"For a given order n, a Chebyshev sequence space is the span of phi_0 phi_1 dots phi_n where phi_0(t) bydef 1, phi_1(t) bydef t and phi_k(t) bydef 2 t phi_k-1(t) - phi_k-2(t) for k = 2 dots n and t in -1 1.\n\nIt is important to note that the coefficients a_0 a_1 dots a_n associated with a Chebyshev space are normalized such that a_0 2a_1 dots 2a_n are the actual Chebyshev coefficients.\n\nùíû = Chebyshev(1)\norder(ùíû)\ndimension(ùíû)\nindices(ùíû)","category":"section"},{"location":"manual/vector_spaces/#Tensor-space","page":"Vector spaces","title":"Tensor space","text":"A TensorSpace is the tensor product of some BaseSpace. The standard constructor for TensorSpace is the ‚äó (\\otimes<tab>) operator.\n\nùíØ_otimes_‚Ñ±_otimes_ùíû = Taylor(1) ‚äó Fourier(1, 1.0) ‚äó Chebyshev(1) # TensorSpace((Taylor(1), Fourier(1, 1.0), Chebyshev(1)))\nnspaces(ùíØ_otimes_‚Ñ±_otimes_ùíû)\norder(ùíØ_otimes_‚Ñ±_otimes_ùíû)\nfrequency(ùíØ_otimes_‚Ñ±_otimes_ùíû, 2)\ndimension(ùíØ_otimes_‚Ñ±_otimes_ùíû)\ndimensions(ùíØ_otimes_‚Ñ±_otimes_ùíû)\nindices(ùíØ_otimes_‚Ñ±_otimes_ùíû)","category":"section"},{"location":"manual/vector_spaces/#Cartesian-space","page":"Vector spaces","title":"Cartesian space","text":"CartesianSpace is the abstract type for all cartesian spaces.\n\nCartesianSpace\n‚îú‚îÄ CartesianPower\n‚îî‚îÄ CartesianProduct","category":"section"},{"location":"manual/vector_spaces/#Cartesian-power","page":"Vector spaces","title":"Cartesian power","text":"A CartesianPower is the cartesian product of an identical VectorSpace. The standard constructor for CartesianPower is the ^ operator.\n\nùíØ¬≤ = Taylor(1) ^ 2 # CartesianPower(Taylor(1), 2)\nnspaces(ùíØ¬≤)\ndimension(ùíØ¬≤)\nindices(ùíØ¬≤)","category":"section"},{"location":"manual/vector_spaces/#Cartesian-product","page":"Vector spaces","title":"Cartesian product","text":"A CartesianProduct is the cartesian product of some VectorSpace. The standard constructor for CartesianProduct is the √ó (\\times<tab>) operator.\n\nùí´_times_ùíØ = ParameterSpace() √ó Taylor(1) # CartesianProduct((ParameterSpace(), Taylor(1)))\nnspaces(ùí´_times_ùíØ)\ndimension(ùí´_times_ùíØ)\nindices(ùí´_times_ùíØ)","category":"section"},{"location":"manual/vector_spaces/#API","page":"Vector spaces","title":"API","text":"","category":"section"},{"location":"manual/vector_spaces/#RadiiPolynomial.BaseSpace","page":"Vector spaces","title":"RadiiPolynomial.BaseSpace","text":"BaseSpace <: SequenceSpace\n\nAbstract type for all sequence spaces that are not a TensorSpace but can be interlaced to form one.\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.CartesianPower","page":"Vector spaces","title":"RadiiPolynomial.CartesianPower","text":"CartesianPower{T<:VectorSpace} <: CartesianSpace\n\nCartesian space resulting from the cartesian product of the same VectorSpace.\n\nFields:\n\nspace :: T\nn :: Int\n\nConstructors:\n\nCartesianPower(::VectorSpace, ::Int)\n^(::VectorSpace, ::Int): equivalent to CartesianPower(::VectorSpace, ::Int)\n\nSee also: ^(::VectorSpace, ::Int), CartesianProduct and √ó.\n\nExamples\n\njulia> s = CartesianPower(Taylor(1), 3)\nTaylor(1)¬≥\n\njulia> space(s)\nTaylor(1)\n\njulia> nspaces(s)\n3\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.CartesianProduct","page":"Vector spaces","title":"RadiiPolynomial.CartesianProduct","text":"CartesianProduct{T<:Tuple{Vararg{VectorSpace}}} <: CartesianSpace\n\nCartesian space resulting from the cartesian product of some VectorSpace.\n\nField:\n\nspaces :: T\n\nConstructors:\n\nCartesianProduct(::Tuple{Vararg{VectorSpace}})\nCartesianProduct(spaces::VectorSpace...): equivalent to CartesianProduct(spaces)\n√ó(s‚ÇÅ::VectorSpace, s‚ÇÇ::VectorSpace): equivalent to CartesianProduct((s‚ÇÅ, s‚ÇÇ))\n√ó(s‚ÇÅ::CartesianProduct, s‚ÇÇ::CartesianProduct): equivalent to CartesianProduct((s‚ÇÅ.spaces..., s‚ÇÇ.spaces...))\n√ó(s‚ÇÅ::CartesianProduct, s‚ÇÇ::VectorSpace): equivalent to CartesianProduct((s‚ÇÅ.spaces..., s‚ÇÇ))\n√ó(s‚ÇÅ::VectorSpace, s‚ÇÇ::CartesianProduct): equivalent to CartesianProduct((s‚ÇÅ, s‚ÇÇ.spaces...))\n\nSee also: √ó, CartesianPower, ^(::VectorSpace, ::Int).\n\nExamples\n\njulia> s = CartesianProduct(Taylor(1), Fourier(2, 1.0), Chebyshev(3))\nTaylor(1) √ó Fourier(2, 1.0) √ó Chebyshev(3)\n\njulia> spaces(s)\n(Taylor(1), Fourier(2, 1.0), Chebyshev(3))\n\njulia> nspaces(s)\n3\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.CartesianSpace","page":"Vector spaces","title":"RadiiPolynomial.CartesianSpace","text":"CartesianSpace <: VectorSpace\n\nAbstract type for all cartesian spaces.\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.Chebyshev","page":"Vector spaces","title":"RadiiPolynomial.Chebyshev","text":"Chebyshev <: BaseSpace\n\nSequence space whose elements are Chebyshev sequences of a prescribed order.\n\nField:\n\norder :: Int\n\nConstructor:\n\nChebyshev(order::Int)\n\nSee also: Taylor and Fourier.\n\nExamples\n\njulia> s = Chebyshev(2)\nChebyshev(2)\n\njulia> order(s)\n2\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.CosFourier","page":"Vector spaces","title":"RadiiPolynomial.CosFourier","text":"CosFourier{T<:Real} <: SymBaseSpace\n\nSequence space whose elements are cosine sequences of a prescribed order and frequency.\n\nField:\n\nspace :: Fourier{T}\n\nConstructors:\n\nCosFourier(space::Fourier)\nCosFourier(order::Int, frequency::Real)\n\nExample\n\njulia> s = CosFourier(2, 1.0)\nCosFourier(2, 1.0)\n\njulia> order(s)\n2\n\njulia> frequency(s)\n1.0\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.EmptySpace","page":"Vector spaces","title":"RadiiPolynomial.EmptySpace","text":"EmptySpace <: VectorSpace\n\nEmpty vector space.\n\nExample\n\njulia> EmptySpace()\n‚àÖ\n\njulia> LinearOperator(EmptySpace(), EmptySpace(), [;;])\nLinearOperator : ‚àÖ ‚Üí ‚àÖ with coefficients Matrix{Any}:\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.Fourier","page":"Vector spaces","title":"RadiiPolynomial.Fourier","text":"Fourier{T<:Real} <: BaseSpace\n\nSequence space whose elements are Fourier sequences of a prescribed order and frequency.\n\nFields:\n\norder :: Int\nfrequency :: T\n\nConstructor:\n\nFourier(order::Int, frequency::Real)\n\nSee also: Taylor and Chebyshev.\n\nExamples\n\njulia> s = Fourier(2, 1.0)\nFourier(2, 1.0)\n\njulia> order(s)\n2\n\njulia> frequency(s)\n1.0\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.ParameterSpace","page":"Vector spaces","title":"RadiiPolynomial.ParameterSpace","text":"ParameterSpace <: VectorSpace\n\nParameter space corresponding to a commutative field.\n\nExample\n\njulia> ParameterSpace()\nùïÇ\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.SequenceSpace","page":"Vector spaces","title":"RadiiPolynomial.SequenceSpace","text":"SequenceSpace <: VectorSpace\n\nAbstract type for all sequence spaces.\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.SinFourier","page":"Vector spaces","title":"RadiiPolynomial.SinFourier","text":"SinFourier{T<:Real} <: SymBaseSpace\n\nSequence space whose elements are sine sequences of a prescribed order and frequency.\n\nField:\n\nspace :: Fourier{T}\n\nConstructors:\n\nSinFourier(space::Fourier)\nSinFourier(order::Int, frequency::Real)\n\nExample\n\njulia> s = SinFourier(2, 1.0)\nSinFourier(2, 1.0)\n\njulia> order(s)\n2\n\njulia> frequency(s)\n1.0\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.Taylor","page":"Vector spaces","title":"RadiiPolynomial.Taylor","text":"Taylor <: BaseSpace\n\nSequence space whose elements are Taylor sequences of a prescribed order.\n\nField:\n\norder :: Int\n\nConstructor:\n\nTaylor(order::Int)\n\nSee also: Fourier and Chebyshev.\n\nExamples\n\njulia> s = Taylor(2)\nTaylor(2)\n\njulia> order(s)\n2\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.TensorIndices","page":"Vector spaces","title":"RadiiPolynomial.TensorIndices","text":"TensorIndices{<:Tuple}\n\nMultidimentional rectangular range of indices for some TensorSpace.\n\nExamples\n\njulia> TensorIndices((0:2, -1:1))\nTensorIndices{Tuple{UnitRange{Int64}, UnitRange{Int64}}}((0:2, -1:1))\n\njulia> indices(Taylor(2) ‚äó Fourier(1, 1.0))\nTensorIndices{Tuple{UnitRange{Int64}, UnitRange{Int64}}}((0:2, -1:1))\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.TensorSpace","page":"Vector spaces","title":"RadiiPolynomial.TensorSpace","text":"TensorSpace{T<:Tuple{Vararg{BaseSpace}}} <: SequenceSpace\n\nSequence space resulting from the tensor product of some BaseSpace.\n\nField:\n\nspaces :: T\n\nConstructors:\n\nTensorSpace(spaces::Tuple{Vararg{BaseSpace}})\nTensorSpace(spaces::BaseSpace...)\n‚äó(s‚ÇÅ::BaseSpace, s‚ÇÇ::BaseSpace): equivalent to TensorSpace((s‚ÇÅ, s‚ÇÇ))\n‚äó(s‚ÇÅ::TensorSpace, s‚ÇÇ::TensorSpace): equivalent to TensorSpace((s‚ÇÅ.spaces..., s‚ÇÇ.spaces...))\n‚äó(s‚ÇÅ::TensorSpace, s‚ÇÇ::BaseSpace): equivalent to TensorSpace((s‚ÇÅ.spaces..., s‚ÇÇ))\n‚äó(s‚ÇÅ::BaseSpace, s‚ÇÇ::TensorSpace): equivalent to TensorSpace((s‚ÇÅ, s‚ÇÇ.spaces...))\n\nSee also: ‚äó.\n\nExamples\n\njulia> s = TensorSpace(Taylor(1), Fourier(2, 1.0), Chebyshev(3))\nTaylor(1) ‚äó Fourier(2, 1.0) ‚äó Chebyshev(3)\n\njulia> spaces(s)\n(Taylor(1), Fourier(2, 1.0), Chebyshev(3))\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#RadiiPolynomial.VectorSpace","page":"Vector spaces","title":"RadiiPolynomial.VectorSpace","text":"VectorSpace\n\nAbstract type for all vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"manual/vector_spaces/#LinearAlgebra.:√ó-Tuple{VectorSpace, VectorSpace}","page":"Vector spaces","title":"LinearAlgebra.:√ó","text":"√ó(::VectorSpace, ::VectorSpace)\n√ó(::CartesianProduct, ::CartesianProduct)\n√ó(::CartesianProduct, ::VectorSpace)\n√ó(::VectorSpace, ::CartesianProduct)\n\nCreate a CartesianProduct from the cartesian product of some VectorSpace.\n\nSee also: CartesianProduct, CartesianPower and ^(::VectorSpace, ::Int).\n\nExamples\n\njulia> Taylor(1) √ó Fourier(2, 1.0)\nTaylor(1) √ó Fourier(2, 1.0)\n\njulia> Taylor(1) √ó Fourier(2, 1.0) √ó Chebyshev(3)\nTaylor(1) √ó Fourier(2, 1.0) √ó Chebyshev(3)\n\njulia> (Taylor(1) √ó Fourier(2, 1.0)) √ó Chebyshev(3)\nTaylor(1) √ó Fourier(2, 1.0) √ó Chebyshev(3)\n\njulia> Taylor(1) √ó (Fourier(2, 1.0) √ó Chebyshev(3))\nTaylor(1) √ó Fourier(2, 1.0) √ó Chebyshev(3)\n\njulia> ParameterSpace()^2 √ó ((Taylor(1) ‚äó Fourier(2, 1.0)) √ó Chebyshev(3))^3\nùïÇ¬≤ √ó ((Taylor(1) ‚äó Fourier(2, 1.0)) √ó Chebyshev(3))¬≥\n\n\n\n\n\n","category":"method"},{"location":"manual/vector_spaces/#RadiiPolynomial.:‚äó-Tuple{BaseSpace, BaseSpace}","page":"Vector spaces","title":"RadiiPolynomial.:‚äó","text":"‚äó(s‚ÇÅ::BaseSpace, s‚ÇÇ::BaseSpace)\n‚äó(s‚ÇÅ::TensorSpace, s‚ÇÇ::TensorSpace)\n‚äó(s‚ÇÅ::TensorSpace, s‚ÇÇ::BaseSpace)\n‚äó(s‚ÇÅ::BaseSpace, s‚ÇÇ::TensorSpace)\n\nCreate a TensorSpace from the tensor product of some SequenceSpace.\n\nSee also: TensorSpace.\n\nExamples\n\njulia> Taylor(1) ‚äó Fourier(2, 1.0)\nTaylor(1) ‚äó Fourier(2, 1.0)\n\njulia> Taylor(1) ‚äó Fourier(2, 1.0) ‚äó Chebyshev(3)\nTaylor(1) ‚äó Fourier(2, 1.0) ‚äó Chebyshev(3)\n\njulia> Taylor(1) ‚äó (Fourier(2, 1.0) ‚äó Chebyshev(3))\nTaylor(1) ‚äó Fourier(2, 1.0) ‚äó Chebyshev(3)\n\njulia> (Taylor(1) ‚äó Fourier(2, 1.0)) ‚äó Chebyshev(3)\nTaylor(1) ‚äó Fourier(2, 1.0) ‚äó Chebyshev(3)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"<!--\nJulia colors:\n#1f83ff (blue)\n#CA3C32 (red)\n#399746 (green)\n#9259A3 (purple)\n-->\n\n<h1 style=\"text-align: center; font-size: 2.5em; color: #1f83ff\">RadiiPolynomial.jl</h1>\n\n<div class=\"row\">\n  <div class=\"column\">\n    <h3 style=\"text-align: center; color: #CA3C32;\">Installation</h3>\n\njulia> using Pkg # Julia v1.10 or above\n\njulia> Pkg.add(\"RadiiPolynomial\")\n\n  </div>\n  <div class=\"column\">\n    <h3 style=\"text-align: center; color: #399746;\">Open source</h3>\n    <p>The RadiiPolynomial library is an open source software under the <a href=\"https://github.com/OlivierHnt/RadiiPolynomial.jl/blob/main/LICENSE.md\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">MIT license</a></p>\n    <p style=\"text-align: center;\"><a href=\"https://github.com/OlivierHnt/RadiiPolynomial.jl\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">github.com/OlivierHnt/RadiiPolynomial.jl</a></p>\n  </div>\n</div>\n<div class=\"row\">\n  <div class=\"single\">\n    <h3 style=\"text-align: center; color: #9259A3;\">Citation</h3>\n    <p>If you use the RadiiPolynomial library in your publication, research, teaching, or other activities, please use the BibTeX template <a href=\"https://github.com/OlivierHnt/RadiiPolynomial.jl/blob/main/CITATION.bib\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">CITATION.bib</a></p>\n    <p style=\"text-align: center;\"><a href=\"https://doi.org/10.5281/zenodo.5705258\" rel=\"nofollow noopener noreferrer\" target=\"_blank\">10.5281/zenodo.5705258</a></p>\n  </div>\n</div>","category":"section"},{"location":"examples/finite_dimensional_proofs/fhn_pseudo_arclength/#Pseudo-arclength-continuation-of-equilibria-of-the-FitzHugh-Nagumo-model","page":"Pseudo-arclength continuation of equilibria of the FitzHugh-Nagumo model","title":"Pseudo-arclength continuation of equilibria of the FitzHugh-Nagumo model","text":"In this example, we will prove the existence of a branch of equilibria of the FitzHugh-Nagumo model\n\nbegincases\ndisplaystyle fracddt u(t) = f(u(t) gamma) bydef beginpmatrix u_1(t)(u_1(t) - a)(1 - u_1(t)) - u_2(t)  varepsilon(u_1(t) - gamma u_2(t)) endpmatrix\nu(0) = u_0 in mathbbR^2\nendcases\n\nwhere a = 5 and varepsilon = 1.\n\nThe vector-field f and its Jacobian, denoted Df, may be implemented as follows:\n\nfunction f(u, Œ≥)\n    a, œµ = 5, 1\n    u‚ÇÅ, u‚ÇÇ = u\n    return [u‚ÇÅ*(u‚ÇÅ - a)*(1 - u‚ÇÅ) - u‚ÇÇ, œµ*(u‚ÇÅ - Œ≥*u‚ÇÇ)]\nend\n\nfunction D·µ§f(u, Œ≥)\n    a, œµ = 5, 1\n    u‚ÇÅ, u‚ÇÇ = u\n    return [a*(2u‚ÇÅ-1)+(2-3u‚ÇÅ)*u‚ÇÅ -1\n            œµ                    -œµ*Œ≥]\nend\n\nfunction ‚àÇŒ≥f(u, Œ≥)\n    a, œµ = 5, 1\n    u‚ÇÅ, u‚ÇÇ = u\n    return [0, -œµ*u‚ÇÇ]\nend\nnothing # hide\n\nWe use the pseudo-arclength continuation and retrieve a numerical approximation of the curve. By a contraction argument, we then prove that there exists a surrounding region that contains the desired curve.\n\nIn a nutshell, the pseudo-arclength continuation consists in computing a sequence of numerical zeros of f. Starting with an initial approximate zero x_textinit in mathbbR^3, we retrieve an approximate tangent vector v to the curve at x_textinit by looking at ker Df(x_textinit). Then, our predictor for the next zero is set to w bydef x_textinit + delta v where delta  0 represents the step size. The Newton's method is applied on the mapping F_textNewton  mathbbR^3 to mathbbR^3 given by\n\nF_textNewton(x) bydef\nbeginpmatrix\nf(x) \n(x - w) cdot v\nendpmatrix\n\nThe mapping F_textNewton and its Jacobian may be implemented as follows:\n\nimport LinearAlgebra: ‚ãÖ\n\nF(x, v, w) = [f(x[1:2], x[3]) ; (x - w) ‚ãÖ v]\n\nDF(x, v) = [D·µ§f(x[1:2], x[3]) ‚àÇŒ≥f(x[1:2], x[3]) ; transpose(v)]\nnothing # hide\n\nNext, we perform Newton's method:\n\nusing RadiiPolynomial\nimport LinearAlgebra: nullspace\n\n# initial point on the branch of equilibria\n\nŒ≥_init = 2.0\n\nu_init = [1.1, 0.5]\nu_init, success = newton(u -> (f(u, Œ≥_init), D·µ§f(u, Œ≥_init)), u_init)\n\n# next point on the branch of equilibria\n\nx_init = [u_init ; Œ≥_init]\n\nv = vec(nullspace([D·µ§f(x_init[1:2], x_init[3]) ‚àÇŒ≥f(x_init[1:2], x_init[3])])) # initial tangent vector\n\nŒ¥ = 5e-2 # step size\n\nw = x_init + Œ¥ * v # predictor\n\nx_final, success = newton(x -> (F(x, v, w), DF(x, v)), w)\nnothing # hide\n\nWhenever Newton's method is successful, we proceed to the next iteration of the pseudo-arclength continuation by repeating the above strategy. Performing this sufficiently many times, we can construct an order N polynomial approximation of the curve of zeros:\n\nbx(s) bydef bx_0 + 2 sum_n = 1^N bx_n phi_n (s) qquad textfor all  s in -11\n\nwhere phi_n are the Chebyshev polynomials of the first kind.\n\nDefine the mapping F  mathbbR^3 times -11 to mathbbR^3 by\n\nF(x s) bydef\nbeginpmatrix\nf(x) \n(x - bx(s)) cdot barv(s)\nendpmatrix\n\nand the fixed-point operator T  mathbbR^3 times -11 to mathbbR^3 by\n\nT(x s) bydef x - A(s) F(x s)\n\nwhere A(s)  mathbbR^3 to mathbbR^3 is the injective operator corresponding to a numerical approximation of D_x F(bx(s) s)^-1 for all s in -1 1.\n\nLet R  0. We use a uniform version of the second-order Radii Polynomial Theorem (cf. Section Radii polynomial approach) such that we need to estimate T(bx(s) s) - bx(s)_1, D_x T(bx(s) s)_1 and sup_x in textcl( B_R(bx(s)) ) D_x^2 T(x s)_1 for all s in -11. In particular, we have\n\nT(bx(s) s) - bx(s)_1 = leftA(s) beginpmatrix f(bx(s))  0 endpmatrix right_1 qquad textfor all  s in -11\n\nThe computer-assisted proof may be implemented as follows:\n\nN = 700\nN_fft = nextpow(2, 2N + 1)\nnpts = N_fft √∑ 2 + 1\n\narclength = 15.0\narclength_grid = [0.5 * arclength - 0.5 * cospi(2j/N_fft) * arclength for j ‚àà 0:npts-1]\nx_grid = Vector{Vector{Float64}}(undef, npts)\nv_grid = Vector{Vector{Float64}}(undef, npts)\n\n# initialize\n\ndirection = [0, 0, -1] # starts by decreasing the parameter\nx_grid[1] = x_init\nv_grid[1] = vec(nullspace([D·µ§f(x_grid[1][1:2], x_grid[1][3]) ‚àÇŒ≥f(x_grid[1][1:2], x_grid[1][3])]))\nif direction ‚ãÖ v_grid[1] < 0 # enforce direction\n    v_grid[1] .*= -1\nend\n\n# run continuation scheme\n\nfor i ‚àà 2:npts\n    Œ¥·µ¢ = arclength_grid[i] - arclength_grid[i-1]\n\n    w·µ¢ = x_grid[i-1] .+ Œ¥·µ¢ .* v_grid[i-1]\n\n    x, success = newton(x -> (F(x, v_grid[i-1], w·µ¢), DF(x, v_grid[i-1])), w·µ¢; verbose = true)\n    success || error()\n\n    x_grid[i] = x\n    v_grid[i] = vec(nullspace([D·µ§f(x_grid[i][1:2], x_grid[i][3]) ‚àÇŒ≥f(x_grid[i][1:2], x_grid[i][3])]))\n    if v_grid[i-1] ‚ãÖ v_grid[i] < 0 # keep the same direction\n        v_grid[i] .*= -1\n    end\nend\n\n# construct the approximations\n\ngrid2cheb(x_fft::Vector{<:Vector}, N) =\n    [rifft!(complex.(getindex.(x_fft, i)), Chebyshev(N)) for i ‚àà eachindex(x_fft[1])]\n\ngrid2cheb(x_fft::Vector{<:Matrix}, N) =\n    [rifft!(complex.(getindex.(x_fft, i, j)), Chebyshev(N)) for i ‚àà axes(x_fft[1], 1), j ‚àà axes(x_fft[1], 2)]\n\nx_fft = [reverse(x_grid) ; x_grid[begin+1:end-1]]\nxÃÑ = map(x -> interval.(x), grid2cheb(x_fft, N))\n\nv_fft = [reverse(v_grid) ; v_grid[begin+1:end-1]]\nvÃÑ = map(v -> interval.(v), grid2cheb(v_fft, N))\n\nA = map(A -> interval.(A), grid2cheb(inv.(DF.(x_fft, v_fft)), N))\n\n# compute the bounds\n\nfunction cheb2grid(x::VecOrMat{<:Sequence}, N_fft)\n    vals = fft.(x, N_fft)\n    return [real.(getindex.(vals, i)) for i ‚àà eachindex(vals[1])]\nend\n\n# AF is a polynomial with respect to s of order 4N\n\nN4 = 4N\nN4_fft = nextpow(2, 2N4 + 1)\n\nAF_fft = cheb2grid(A, N4_fft) .* F.(cheb2grid(xÃÑ, N4_fft), cheb2grid(vÃÑ, N4_fft), cheb2grid(xÃÑ, N4_fft))\nAF = grid2cheb(AF_fft, N4)\n\nY = norm(norm.(AF, 1), 1)\n\n# ADF is a polynomial with respect to s of order 3N\n\nN3 = 3N\nN3_fft = nextpow(2, 2N3 + 1)\n\nI_ADF_fft = [I] .- cheb2grid(A, N3_fft) .* DF.(cheb2grid(xÃÑ, N3_fft), cheb2grid(vÃÑ, N3_fft))\nI_ADF = grid2cheb(I_ADF_fft, N3)\n\nZ‚ÇÅ = opnorm(norm.(I_ADF, 1), 1)\n\n#\n\nR = 1.2sup(Y)\n\na, œµ = 5, 1\nZ‚ÇÇ = opnorm(norm.(A, 1), 1) * max(abs(2a + 2) + 6(norm(xÃÑ[1], 1) + R) + abs(œµ), abs(œµ))\n\n#\n\nsetdisplay(:full)\n\ninterval_of_existence(Y, Z‚ÇÅ, Z‚ÇÇ, R)\n\nThe following figure[1] shows the numerical approximation of the proven branch of equilibria of the FitzHugh-Nagumo model.\n\n[1]: S. Danisch and J. Krumbiegel, Makie.jl: Flexible high-performance data visualization for Julia, Journal of Open Source Software, 6 (2021), 3349.\n\n(Image: )","category":"section"}]
}
