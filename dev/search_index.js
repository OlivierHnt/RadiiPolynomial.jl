var documenterSearchIndex = {"docs":
[{"location":"radii_polynomial_approach/#Radii-polynomial-approach","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"","category":"section"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"Let X be a Banach space, U an open subset of X, T  U to X an operator, x_0 in U and R geq 0 such that textcl( B_R(x_0) ) subset U.","category":"page"},{"location":"radii_polynomial_approach/#first_order_RPT","page":"Radii polynomial approach","title":"First-order Radii Polynomial Theorem","text":"","category":"section"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"Suppose T in C^1(U X) and Y Z_1 geq 0 satisfy","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"beginaligned\nT(x_0) - x_0_X leq Y\nsup_x in textcl( B_R(x_0) ) DT(x)_mathscrB(X X) leq Z_1\nendaligned","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"and define the radii polynomial by","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"p(r) = Y + (Z_1 - 1) r","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"If there exists a radius r_0 in 0 R such that","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"p(r_0) leq 0 qquad textand qquad Z_1  1","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"then T has a unique fixed point in textcl( B_r_0 (x_0) ).","category":"page"},{"location":"radii_polynomial_approach/#Second-order-Radii-Polynomial-Theorem","page":"Radii polynomial approach","title":"Second-order Radii Polynomial Theorem","text":"","category":"section"},{"location":"radii_polynomial_approach/#C1-condition","page":"Radii polynomial approach","title":"C^1 condition","text":"","category":"section"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"Suppose T in C^1(U X) and Y Z_1 Z_2 geq 0 satisfy","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"beginaligned\nT(x_0) - x_0_X leq Y\nDT(x_0)_mathscrB(X X) leq Z_1\nDT(x) - DT(x_0)_mathscrB(X X) leq Z_2 x - x_0 qquad textfor all  x in textcl( B_R(x_0) )\nendaligned","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"and define the radii polynomial by","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"p(r) = Y + (Z_1 - 1) r + fracZ_22 r^2","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"If there exists a radius r_0 in 0 R such that","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"p(r_0) leq 0 qquad textand qquad Z_1 + Z_2 r_0  1","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"then T has a unique fixed point in textcl( B_r_0 (x_0) ).","category":"page"},{"location":"radii_polynomial_approach/#C2_condition_RPT","page":"Radii polynomial approach","title":"C^2 condition","text":"","category":"section"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"Suppose T in C^2(U X) and Y Z_1 Z_2 geq 0 satisfy","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"beginaligned\nT(x_0) - x_0_X leq Y\nDT(x_0)_mathscrB(X X) leq Z_1\nsup_x in textcl( B_R(x_0) ) D^2T(x)_mathscrB(X^2 X) leq Z_2\nendaligned","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"and define the radii polynomial by","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"p(r) = Y + (Z_1 - 1) r + fracZ_22 r^2","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"If there exists a radius r_0 in 0 R such that","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"p(r_0) leq 0 qquad textand qquad Z_2 r_0  1","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"then T has a unique fixed point in textcl( B_r_0 (x_0) ).","category":"page"},{"location":"radii_polynomial_approach/#Interval-of-existence","page":"Radii polynomial approach","title":"Interval of existence","text":"","category":"section"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"The set of all possible radii is called the interval of existence.","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"The infimum of the interval of existence gives the sharpest computed a posteriori error bound on x_0. The supremum of the interval of existence represents the largest computed radius of the ball centred at x_0 within which the solution is unique.","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"The interval_of_existence method returns an Interval such that p is negative.","category":"page"},{"location":"radii_polynomial_approach/","page":"Radii polynomial approach","title":"Radii polynomial approach","text":"interval_of_existence(Y::Interval{T}, Z₁::Interval{T}, R::T) where {T<:Real}\ninterval_of_existence(Y::Interval{T}, Z₁::Interval{T}, Z₂::Interval{T}, R::T, ::C¹Condition) where {T<:Real}\ninterval_of_existence(Y::Interval{T}, Z₁::Interval{T}, Z₂::Interval{T}, R::T, ::C²Condition) where {T<:Real}","category":"page"},{"location":"radii_polynomial_approach/#RadiiPolynomial.interval_of_existence-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, T}} where T<:Real","page":"Radii polynomial approach","title":"RadiiPolynomial.interval_of_existence","text":"interval_of_existence(Y::Interval{T}, Z₁::Interval{T}, R::T) where {T<:Real}\n\nReturn an interval of existence I subset 0 R such that Y + (Z_1 - 1) r leq 0 and Z_1  1 for all r in I.\n\n\n\n\n\n","category":"method"},{"location":"radii_polynomial_approach/#RadiiPolynomial.interval_of_existence-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, Interval{T}, T, C¹Condition}} where T<:Real","page":"Radii polynomial approach","title":"RadiiPolynomial.interval_of_existence","text":"interval_of_existence(Y::Interval{T}, Z₁::Interval{T}, Z₂::Interval{T}, R::T, ::C¹Condition) where {T<:Real}\n\nReturn an interval of existence I subset 0 R such that Y + (Z_1 - 1) r + Z_2 r^2  2 leq 0 and Z_1 + Z_2 r  1 for all r in I.\n\n\n\n\n\n","category":"method"},{"location":"radii_polynomial_approach/#RadiiPolynomial.interval_of_existence-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, Interval{T}, T, C²Condition}} where T<:Real","page":"Radii polynomial approach","title":"RadiiPolynomial.interval_of_existence","text":"interval_of_existence(Y::Interval{T}, Z₁::Interval{T}, Z₂::Interval{T}, R::T, ::C²Condition) where {T<:Real}\n\nReturn an interval of existence I subset 0 R such that Y + (Z_1 - 1) r + Z_2 r^2  2 leq 0 and Z_2 r  1 for all r in I.\n\n\n\n\n\n","category":"method"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"using RadiiPolynomial","category":"page"},{"location":"sequence_spaces/linear_operators/#Linear-operators","page":"Linear operators","title":"Linear operators","text":"","category":"section"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"A LinearOperator is a structure representing a linear operator from a VectorSpace to an other. More precisely, a LinearOperator is comprised of the three fields domain::VectorSpace, codomain::VectorSpace and coefficients::AbsractMatrix with matching dimensions and size.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"A = LinearOperator(Taylor(1), Taylor(1), [1 2 ; 3 4])","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The three fields domain, codomain and coefficients are accessible via the respective functions of the same name.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"domain(A)\ncodomain(A)\ncoefficients(A)","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The coefficients of a LinearOperator are indexed according to the indices of the domain and codomain (as given by indices).","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"A[0:1,0:1] # indices(domain(A)), indices(codomain(A))","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"When the domain and/or the codomain of a LinearOperator is a CartesianSpace, its coefficients can be thought of as a block matrix . The function component extracts a LinearOperator composing the cartesian space.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"B = LinearOperator(ParameterSpace() × Taylor(1)^2, ParameterSpace() × Taylor(1)^2, reshape(1:25, 5, 5))\nB[1:5,1:5] # indices(domain(B)), indices(codomain(B))\ncomponent(B, 1, 1) # extract the linear operator associated with the domain ParameterSpace() and codomain ParameterSpace()\ncomponent(B, 2, 2) # extract the linear operator associated with the domain Taylor(1)^2 and codomain Taylor(1)^2\ncomponent(component(B, 2, 2), 1, 1)\ncomponent(component(B, 2, 2), 2, 2)","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"Similarly, the function eachcomponent returns a Generator whose iterates yield each LinearOperator composing the cartesian space.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"LinearOperator","category":"page"},{"location":"sequence_spaces/linear_operators/#RadiiPolynomial.LinearOperator","page":"Linear operators","title":"RadiiPolynomial.LinearOperator","text":"LinearOperator{T<:VectorSpace,S<:VectorSpace,R<:AbstractMatrix}\n\nCompactly supported operator with effective domain and codomain.\n\nFields:\n\ndomain :: T\ncodomain :: S\ncoefficients :: R\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/linear_operators/#Arithmetic","page":"Linear operators","title":"Arithmetic","text":"","category":"section"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The addition and subtraction operations are implemented as the + and - functions respectively. Their bar counterparts +̄ (+\\bar<TAB>) and -̄ (-\\bar<TAB>) give the result projected in the smallest compatible domain and codomain between the operands.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"C = LinearOperator(Taylor(1), Taylor(1), [1 2 ; 3 4])\nD = LinearOperator(Taylor(1), Taylor(2), [1 2 ; 3 4 ; 5 6])\nC + D\nC - D\nC +̄ D # project(C + D, Taylor(1), Taylor(1))\nC -̄ D # project(C - D, Taylor(1), Taylor(1))\nC + I\nC - I","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The product between LinearOperator is implemented as the *, or equivalently ∘, and ^ functions. The division between LinearOperator is implemented as the \\ method.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"C * D # C ∘ D\nC ^ 3\nC \\ C","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The action of a LinearOperator is performed by the right product * of a LinearOperator with a Sequence; alternatively, LinearOperator defines a method on a Sequence representing *. Naturally, the resulting sequence is an element of the codomain of the LinearOperator.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"Conversely, the operator \\ between a LinearOperator and a Sequence corresponds to the action of the inverse of the LinearOperator; the output sequence is an element of the domain of the LinearOperator.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"x = Sequence(Taylor(2), [1, 1, 1])\nC * x # C(x)\nD \\ x","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"using RadiiPolynomial","category":"page"},{"location":"sequence_spaces/norms/#Norms","page":"Norms","title":"Norms","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The spaces introduced in the section Vector spaces are not normed a priori. Indeed, to satisfy the Radii Polynomial Theorem, it is useful to tune the Banach space on the fly.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"All Banach spaces mentioned below are a subtype of the abstract type BanachSpace.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"BanachSpace\n├─ NormedCartesianSpace\n├─ Weightedℓ¹\n├─ ℓ¹\n├─ ℓ∞\n└─ Hˢ","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"BanachSpace","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.BanachSpace","page":"Norms","title":"RadiiPolynomial.BanachSpace","text":"BanachSpace\n\nAbstract type for all Banach spaces.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#\\ell1-and-\\ell\\infty","page":"Norms","title":"ell^1 and ell^infty","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Let mathscrI be a set of indices such that mathscrI subset mathbbZ^d for some d in mathbbN.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The ell^1 space is defined as","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"ell^1 = left a in mathbbC^mathscrI    +infty   a _ell^1 = sum_alpha in mathscrI  a_alpha  right","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"and the ell^infty space is defined as","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"ell^infty = left a in mathbbC^mathscrI    +infty   a _ell^infty = sup_alpha in mathscrI  a_alpha  right","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"These Banach spaces are representing by the structures ℓ¹ (\\ell<TAB>\\^1<TAB>) and ℓ∞ (\\ell<TAB>\\infty<TAB>).","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(2), [1.0, 2.0, 3.0])\nnorm(a, ℓ¹())\nnorm(a, ℓ∞())","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"ℓ¹\nℓ∞","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.ℓ¹","page":"Norms","title":"RadiiPolynomial.ℓ¹","text":"ℓ¹ <: BanachSpace\n\nell^1 Banach space.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#RadiiPolynomial.ℓ∞","page":"Norms","title":"RadiiPolynomial.ℓ∞","text":"ℓ∞ <: BanachSpace\n\nell^infty Banach space.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#Weighted-\\ell1","page":"Norms","title":"Weighted ell^1","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The Weightedℓ¹ (Weighted\\ell<TAB>\\^1<TAB>) represents a weighted ell^1 space.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Weightedℓ¹","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.Weightedℓ¹","page":"Norms","title":"RadiiPolynomial.Weightedℓ¹","text":"Weightedℓ¹{T<:Union{Weights,Tuple{Vararg{Weights}}}} <: BanachSpace\n\nWeighted ell^1 Banach space.\n\nFields:\n\nweights :: T\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#Geometric-weights","page":"Norms","title":"Geometric weights","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Let mathscrI be a set of indices such that mathscrI subset mathbbZ^d for some d in mathbbN.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The geometric weights of rate nu  0 are the numbers nu^alpha for all alpha in mathscrI. The corresponding weighted ell^1 space is defined as","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"ell^1_nu = left a in mathbbC^mathscrI    +infty   a _ell^1_nu = sum_alpha in mathscrI a_alpha nu^alpha right","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(2), [1.0, 2.0, 3.0])\nnorm(a, Weightedℓ¹(GeometricWeights(2.0)))","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Note that such a Banach space may also yield a Banach algebra for a suitable choice of the rate nu. Namely,","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"for Taylor, ell^1_nu is a Banach algebra for all nu  0 .\nfor Fourier and Chebyshev, ell^1_nu is a Banach algebra for all nu geq 1.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(2) ⊗ Fourier(2, 1.) ⊗ Chebyshev(2), ones(3*5*3));\nb = Sequence(Taylor(1) ⊗ Fourier(3, 1.) ⊗ Chebyshev(0), ones(2*7*1));\nX = Weightedℓ¹((GeometricWeights(0.2), GeometricWeights(1.2), GeometricWeights(2.0)));\nnorm(a*b, X)\nnorm(a, X) * norm(b, X)","category":"page"},{"location":"sequence_spaces/norms/#Algebraic-weights","page":"Norms","title":"Algebraic weights","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Let mathscrI be a set of indices such that mathscrI subset mathbbZ^d for some d in mathbbN.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The algebraic weights of rate s geq 0 are the numbers (1 + alpha)^s for all alpha in mathscrI. The corresponding weighted ell^1 space is defined as","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"ell^1_s = left a in mathbbC^mathscrI    +infty   a _ell^1_s = sum_alpha in mathscrI a_alpha (1 + alpha)^s right","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(2), [1.0, 2.0, 3.0])\nnorm(a, Weightedℓ¹(AlgebraicWeights(2.0)))","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Note that such a Banach space may also yield a Banach algebra.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(2) ⊗ Fourier(2, 1.) ⊗ Chebyshev(2), ones(3*5*3));\nb = Sequence(Taylor(1) ⊗ Fourier(3, 1.) ⊗ Chebyshev(0), ones(2*7*1));\nX = Weightedℓ¹((AlgebraicWeights(0.2), AlgebraicWeights(1.2), AlgebraicWeights(2.0)));\nnorm(a*b, X)\nnorm(a, X) * norm(b, X)","category":"page"},{"location":"sequence_spaces/norms/#Hs","page":"Norms","title":"H^s","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Let mathscrI be a set of indices such that mathscrI subset mathbbZ^d for some d in mathbbN and s in 1 +infty). The Sobolev space H^s is defined as","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"H^s = left a in mathbbC^mathscrI    +infty   a _H^s = left( sum_alpha in mathscrI  a_alpha  left( 1 + sum_i=1^d  alpha_i ^2 right)^s right)^12 right","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The Hˢ (\\itH<TAB>\\^s<TAB>) wraps such a s.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Fourier(1, 1.0), [0.5, 0.0, 0.5])\nnorm(a, Hˢ(2.0))","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Hˢ","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.Hˢ","page":"Norms","title":"RadiiPolynomial.Hˢ","text":"Hˢ{T<:Real} <: BanachSpace\n\nH^s Sobolev space.\n\nFields:\n\nexponent :: T\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#Normed-cartesian-space","page":"Norms","title":"Normed cartesian space","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"For the norm of a CartesianSpace, one may use a NormedCartesianSpace to either:","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"use the same BanachSpace for each space.\nuse a different BanachSpace for each space.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(1)^2 × Chebyshev(1)^2, [1, 2, 3, 4, 5, 6, 7, 8])\ninner = NormedCartesianSpace((Weightedℓ¹(GeometricWeights(2.0)), Weightedℓ¹(AlgebraicWeights(3.0))), ℓ∞())\nnorm(a, NormedCartesianSpace(inner, ℓ¹()))","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"NormedCartesianSpace","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.NormedCartesianSpace","page":"Norms","title":"RadiiPolynomial.NormedCartesianSpace","text":"NormedCartesianSpace{T<:BanachSpace,S<:BanachSpace} <: BanachSpace\n\nCartesian Banach space.\n\nFields:\n\ninner :: T\nouter :: S\n\n\n\n\n\n","category":"type"},{"location":"examples/infinite_dimensional_proofs/ivp/#Initial-value-problem-for-Ordinary-Differential-Equations-(ODE)","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"","category":"section"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"In this example, we will prove the existence of a solution of the initial value problem","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"begincases\ndisplaystyle fracddt u(t) = f(u(t)) = u(t)^2 - u(t)\nu(0) = 12\nendcases","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"Let nu  0 and X = (ell^1_nu *) where","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"ell^1_nu = left  x_alpha _alpha geq 0 in mathbbR^mathbbN cup 0     x _ell^1_nu = sum_alpha geq 0 x_alpha nu^alpha  +infty right","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"and *  ell^1_nu times ell^1_nu to ell^1_nu is the Cauchy product given by","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"x * y = left sum_beta = 0^alpha x_alpha - beta y_beta right_alpha geq 0 qquad textfor all  x y in ell^1_nu","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"The Banach algebra X is a suitable space to look for a solution of the initial value problem. Indeed, it is a standard result from ODE theory that analytic vector fields yield analytic solutions. For any sequence x in X, the series sum_alpha geq 0 x_alpha t^alpha defines an analytic function in C^omega(-nu nu mathbbR); while the Cauchy product * corresponds to the product of analytic functions in sequence space.[1]","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"[1]: A. Hungria, J.-P. Lessard and J. D. Mireles James, Rigorous numerics for analytic solutions of differential equations: the radii polynomial approach, Mathematics of Computation, 85 (2016), 1427-1459.","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"It follows that the sequence of coefficients of a Taylor series solving the initial value problem is a zero of the mapping F  X to X given component-wise by","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"( F(x) )_alpha =\nbegincases\nx_0 - 12  alpha = 0\nalpha x_alpha - (x*x - x)_alpha-1  alpha geq 1\nendcases","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"Consider the fixed-point operator T  X to X defined by","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"T(x) = x - A F(x)","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"where A  X to X is the injective operator corresponding to a numerical approximation of DF(x_0)^-1 for some numerical zero x_0 in X of F.","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"Let R  0. Since T in C^2(X X) we may use the second-order Radii Polynomial Theorem with C^2 condition such that we need to estimate T(x_0) - x_0_X, DT(x_0)_mathscrB(X X) and sup_x in textcl( B_R(x_0) ) D^2T(x)_mathscrB(X^2 X).","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"To this end, for all x in X, consider the projection operators","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"beginaligned\n(pi^n x)_alpha = begincases x_alpha  alpha leq n  0  alpha  n endcases\npi^infty(n) x = x - pi^n x\nendaligned","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"Thus, for all x_0 in X and R  0, we have","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"beginaligned\nT(x_0) - x_0_X leq pi^n A pi^n F(x_0)_X + frac1n+1 pi^infty(n) F(x_0)_X\nDT(x_0)_mathscrB(X X) leq pi^n A pi^n DF(x_0) pi^n - I_mathscrB(X X) + fracnun+1 2x_0 - 1_X\nsup_x in textcl( B_R(x_0) ) D^2T(x)_mathscrB(X^2 X) leq 2 nu left( pi^n A pi^n_mathscrB(X X) + frac1n+1 right)\nendaligned","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"In particular, from the latter estimate, we may freely choose R = infty.","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"We can now write our computer-assisted proof:","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"using RadiiPolynomial\n\nfunction F(x::Sequence{Taylor})\n    f = x^2 - x\n    F_ = Sequence(Taylor(order(f)+1), Vector{eltype(x)}(undef, length(f)+1))\n    F_[0] = x[0] - 0.5\n    F_[1:end] .= Derivative(1) * x - f\n    return F_\nend\n\nfunction DF(x::Sequence{Taylor}, domain::Taylor, codomain::Taylor, ::Type{CoefType}) where {CoefType}\n    DF_ = LinearOperator(domain, codomain, zeros(CoefType, dimension(codomain), dimension(domain)))\n    DF_[0,0] = one(CoefType)\n    DF_[1:end,:] .=\n        project(Derivative(1), domain, Taylor(order(codomain)-1), CoefType) .-\n        project(Multiplication(2x - 1), domain, Taylor(order(codomain)-1), CoefType)    \n    return DF_\nend\n\n# numerical solution\n\nn = 27\nx₀ = Sequence(Taylor(n), zeros(n+1))\nx₀, success = newton(x -> (project(F(x), space(x)), DF(x, space(x), space(x), eltype(x))),\n    x₀;\n    verbose = false)\n\n# proof\n\nx₀_interval = Interval.(x₀)\nF_interval = F(x₀_interval)\ntail_F_interval = copy(F_interval)\ntail_F_interval[0:n] .= Interval(0.0)\nDF_interval = DF(x₀_interval, space(x₀_interval), space(x₀_interval), eltype(x₀_interval))\nA = inv(mid.(DF_interval))\nbound_tail_A = inv(Interval(n+1))\n\nν = Interval(1.0)\nX = Weightedℓ¹(GeometricWeights(ν))\nR = Inf\n\nY = norm(A * F_interval, X) + bound_tail_A * norm(tail_F_interval, X)\nZ₁ = opnorm(A * DF_interval - I, X) + bound_tail_A * ν * norm(2x₀_interval - 1, X)\nZ₂ = 2ν * (opnorm(A, X) + bound_tail_A)\nshowfull(interval_of_existence(Y, Z₁, Z₂, R, C²Condition()))","category":"page"},{"location":"sequence_spaces/special_operators/#Special-operators","page":"Special operators","title":"Special operators","text":"","category":"section"},{"location":"sequence_spaces/special_operators/#Projection","page":"Special operators","title":"Projection","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nA = LinearOperator(Taylor(1) ⊗ Chebyshev(1), Taylor(1) ⊗ Chebyshev(1), [1.0 0.0 0.0 0.0 ; 0.0 1.0 0.0 0.0 ; 0.0 0.0 1.0 0.0 ; 0.0 0.0 0.0 1.0])\nproject(A, Taylor(1) ⊗ Chebyshev(2), Taylor(2) ⊗ Chebyshev(1), Float64)","category":"page"},{"location":"sequence_spaces/special_operators/#Multiplication","page":"Special operators","title":"Multiplication","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nA = Multiplication(Sequence(Taylor(1) ⊗ Fourier(1, 1.0), [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]))\nproject(A, Taylor(1) ⊗ Fourier(1, 1.0), Taylor(2) ⊗ Fourier(0, 1.0), Float64)","category":"page"},{"location":"sequence_spaces/special_operators/#Derivation-and-integration","page":"Special operators","title":"Derivation and integration","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Derivative(1), Taylor(2), Taylor(1), Float64)\nproject(Derivative((1, 1)), Taylor(2) ⊗ Fourier(1, 1.0), Taylor(1) ⊗ Fourier(1, 1.0), Complex{Float64})","category":"page"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Integral(1), Taylor(2), Taylor(3), Float64)\nproject(Integral((1, 1)), Taylor(1) ⊗ Fourier(1, 1.0), Taylor(2) ⊗ Fourier(1, 1.0), Complex{Float64})","category":"page"},{"location":"sequence_spaces/special_operators/#Evaluation","page":"Special operators","title":"Evaluation","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Evaluation(0.5), Taylor(2), Taylor(0), Float64)\nproject(Evaluation((0.5, nothing)), Taylor(2) ⊗ Fourier(1, 1.0), Taylor(0) ⊗ Fourier(1, 1.0), Float64)","category":"page"},{"location":"sequence_spaces/special_operators/#Scale","page":"Special operators","title":"Scale","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Scale(2.0), Taylor(2), Taylor(2), Float64)\nproject(Scale((2.0, nothing)), Taylor(2) ⊗ Fourier(1, 1.0), Taylor(2) ⊗ Fourier(1, 1.0), Float64)","category":"page"},{"location":"sequence_spaces/special_operators/#Shift","page":"Special operators","title":"Shift","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Shift(π/2), Fourier(1, 1.0), Fourier(1, 1.0), Complex{Float64})","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"using RadiiPolynomial","category":"page"},{"location":"sequence_spaces/vector_spaces/#vector_spaces","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"RadiiPolynomial defines a variety of vector spaces to represent the Banach space on which one applies the Radii Polynomial Theorem.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"All spaces mentioned below are a subtype of the abstract type VectorSpace.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"VectorSpace\n├─ CartesianSpace\n│  ├─ CartesianPower\n│  └─ CartesianProduct\n├─ ParameterSpace\n└─ SequenceSpace\n   ├─ BaseSpace\n   │  ├─ Chebyshev\n   │  ├─ Fourier\n   │  └─ Taylor\n   └─ TensorSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"VectorSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.VectorSpace","page":"Vector spaces","title":"RadiiPolynomial.VectorSpace","text":"VectorSpace\n\nAbstract type for all vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Parameter-space","page":"Vector spaces","title":"Parameter space","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"A ParameterSpace represents the commutative field of a parameter. This is the standard space to use for an unfolding parameter.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"𝒫 = ParameterSpace()\ndimension(𝒫)\nindices(𝒫)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"ParameterSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.ParameterSpace","page":"Vector spaces","title":"RadiiPolynomial.ParameterSpace","text":"ParameterSpace <: VectorSpace\n\nSpace of a parameter corresponding to a commutative field.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Sequence-space","page":"Vector spaces","title":"Sequence space","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"SequenceSpace is the abstract type for all sequence spaces.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"SequenceSpace\n├─ BaseSpace\n│  ├─ Chebyshev\n│  ├─ Fourier\n│  └─ Taylor\n└─ TensorSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"SequenceSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.SequenceSpace","page":"Vector spaces","title":"RadiiPolynomial.SequenceSpace","text":"SequenceSpace <: VectorSpace\n\nAbstract type for all sequence spaces.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#BaseSpace","page":"Vector spaces","title":"BaseSpace","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"BaseSpace is the abstract type for all sequence spaces that are not a TensorSpace but can be interlaced to form one.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"BaseSpace\n├─ Chebyshev\n├─ Fourier\n└─ Taylor","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"BaseSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.BaseSpace","page":"Vector spaces","title":"RadiiPolynomial.BaseSpace","text":"BaseSpace <: SequenceSpace\n\nAbstract type for all sequence spaces that are not a TensorSpace but can be interlaced to form one.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Taylor","page":"Vector spaces","title":"Taylor","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"For a given order n, a Taylor sequence space is the span of phi_0 dots phi_n where phi_k(t) = t^k for k = 0 dots n and t in -nu nu for some appropriate nu  0.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"𝒯 = Taylor(1)\norder(𝒯)\ndimension(𝒯)\nindices(𝒯)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"Taylor","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.Taylor","page":"Vector spaces","title":"RadiiPolynomial.Taylor","text":"Taylor <: BaseSpace\n\nTaylor sequence space whose elements are Taylor sequences of a prescribed order.\n\nFields:\n\norder :: Int\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Fourier","page":"Vector spaces","title":"Fourier","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"For a given order n and frequency omega, a Fourier sequence space is the span of phi_-n dots phi_n where phi_k(t) = e^i omega k t for k = -n dots n and t in mathbbR2piomega^-1mathbbZ.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"ℱ = Fourier(1, 1.0)\norder(ℱ)\nfrequency(ℱ)\ndimension(ℱ)\nindices(ℱ)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"Fourier","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.Fourier","page":"Vector spaces","title":"RadiiPolynomial.Fourier","text":"Fourier{T} <: BaseSpace\n\nFourier sequence space whose elements are Fourier sequences of a prescribed order and frequency.\n\nFields:\n\norder :: Int\nfrequency :: T\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Chebyshev","page":"Vector spaces","title":"Chebyshev","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"For a given order n, a Chebyshev sequence space is the span of phi_0 phi_1 dots phi_n where phi_0(t) = 1, phi_1(t) = t and phi_k(t) = 2 t phi_k-1(t) - phi_k-2(t) for k = 2 dots n and t in -1 1.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"It is important to note that coefficients a_0 a_1 dots a_n associated to a Chebyshev space are normalized such that a_0 2a_1 dots 2a_n are the actual Chebyshev coefficients.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"𝒞 = Chebyshev(1)\norder(𝒞)\ndimension(𝒞)\nindices(𝒞)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"Chebyshev","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.Chebyshev","page":"Vector spaces","title":"RadiiPolynomial.Chebyshev","text":"Chebyshev <: BaseSpace\n\nChebyshev sequence space whose elements are Chebyshev sequences of a prescribed order.\n\nFields:\n\norder :: Int\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Tensor-space","page":"Vector spaces","title":"Tensor space","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"A TensorSpace is the tensor product of some BaseSpace. The standard constructor for TensorSpace is the ⊗ (\\otimes<TAB>) operator.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"𝒯_otimes_ℱ_otimes_𝒞 = Taylor(1) ⊗ Fourier(1, 1.0) ⊗ Chebyshev(1) # TensorSpace((Taylor(1), Fourier(1, 1.0), Chebyshev(1)))\norder(𝒯_otimes_ℱ_otimes_𝒞)\nfrequency(𝒯_otimes_ℱ_otimes_𝒞, 2)\ndimension(𝒯_otimes_ℱ_otimes_𝒞)\ndimensions(𝒯_otimes_ℱ_otimes_𝒞)\nindices(𝒯_otimes_ℱ_otimes_𝒞)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"TensorSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.TensorSpace","page":"Vector spaces","title":"RadiiPolynomial.TensorSpace","text":"TensorSpace{T<:NTuple{N,BaseSpace} where {N}} <: SequenceSpace\n\nSequenceSpace resulting from the tensor product of some BaseSpace.\n\nFields:\n\nspaces :: T\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Cartesian-space","page":"Vector spaces","title":"Cartesian space","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianSpace is the abstract type for all cartesian spaces.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianSpace\n├─ CartesianPower\n└─ CartesianProduct","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.CartesianSpace","page":"Vector spaces","title":"RadiiPolynomial.CartesianSpace","text":"CartesianSpace <: VectorSpace\n\nAbstract type for all cartesian spaces.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Cartesian-power","page":"Vector spaces","title":"Cartesian power","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"A CartesianPower is the cartesian product of an identical VectorSpace. The standard constructor for CartesianPower is the ^ operator.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"𝒯² = Taylor(1) ^ 2 # CartesianPower(Taylor(1), 2)\nnb_cartesian_product(𝒯²)\ndimension(𝒯²)\nindices(𝒯²)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianPower","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.CartesianPower","page":"Vector spaces","title":"RadiiPolynomial.CartesianPower","text":"CartesianPower{T<:VectorSpace} <: CartesianSpace\n\nCartesian space resulting from the cartesian products of a VectorSpace.\n\nFields:\n\nspace :: T\nn :: Int\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Cartesian-product","page":"Vector spaces","title":"Cartesian product","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"A CartesianProduct is the cartesian product of some VectorSpace. The standard constructor for CartesianProduct is the × (\\times<TAB>) operator.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"𝒫_times_𝒯 = ParameterSpace() × Taylor(1) # CartesianProduct((ParameterSpace(), Taylor(1)))\nnb_cartesian_product(𝒫_times_𝒯)\ndimension(𝒫_times_𝒯)\nindices(𝒫_times_𝒯)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianProduct","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.CartesianProduct","page":"Vector spaces","title":"RadiiPolynomial.CartesianProduct","text":"CartesianProduct{T<:NTuple{N,VectorSpace} where {N}} <: CartesianSpace\n\nCartesian space resulting from N cartesian products of some VectorSpace.\n\nFields:\n\nspaces :: T\n\n\n\n\n\n","category":"type"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/#Pseudo-arclength-continuation","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"","category":"section"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"In this example, we will prove the existence of a branch of equilibria for the FitzHugh-Nagumo model","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"begincases\ndisplaystyle fracddt u(t) = f(gamma u(t)) = beginpmatrix u_1(t)(u_1(t) - a)(1 - u_1(t)) - u_2(t)  varepsilon(u_1(t) - gamma u_2(t)) endpmatrix\nu(0) = u_0 in mathbbR^2\nendcases","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"where a = 5 and varepsilon = 1.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"To this end, we use the pseudo-arclength continuation and prove, at each step, that there exists a box, surrounding the linear numerical approximation, which contains the desired curve.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"In a nutshell, the pseudo-arclength continuation consists in computing a sequence of numerical zeros of f. Starting with an initial zero x_1 in mathbbR^3, we retrieve an approximate tangent vector v_1 to the curve at x_1 by looking at ker Df(x_1). Then, our predictor for the next zero is set to w = x_1 + delta v_1 where delta  0 represents the step size. The Newton's method is applied on the mapping F_textNewton  mathbbR^3 to mathbbR^3 given by","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"F_textNewton(x) =\nbeginpmatrix\n(x - w_1) cdot v_1\nf(x)\nendpmatrix","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"Once the Newton's method converged to some x_2 in mathbbR^3, we make a linear approximation of the curve of zeros and successive tangent vectors","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"beginaligned\nx_0(s) = x_1 + s (x_2 - x_1) qquad textfor all  s in 01\nv_0(s) = v_1 + s (v_2 - v_1) qquad textfor all  s in 01\nendaligned","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"Define the mapping F  mathbbR^3 times 01 to mathbbR^3 by","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"F(x s) =\nbeginpmatrix\n(x - x_0(s)) cdot v_0(s)\nf(x)\nendpmatrix","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"and the fixed-point operator T  mathbbR^3 times 01 to mathbbR^3 by","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"T(x s) = x - A F(x s)","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"Let R  0. We use a uniform version of the first-order Radii Polynomial Theorem such that we need to estimate T(x_0(s) s) - x_0(s)_infty and sup_x in textcl( B_R(x_0(s)) ) DT(x s)_infty for all s in 01. In particular, we have","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"T(x_0(s) s) - x_0(s)_infty = leftA beginpmatrix 0  f(x_0(s)) endpmatrix right_infty qquad textfor all  s in 01","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"Whenever the proof is successful, we proceed to the next iteration of the pseudo-arclength continuation and repeat the above strategy.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"We can now write our computer-assisted proof:","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"using RadiiPolynomial\n\nfunction rigorous_pseudo_arclength(x_ini::Vector{Float64}, step_size::Float64, max_iter::Int)\n    n = length(x_ini)\n    ie_collection = Interval{Float64}[]\n    x_collection = [x_ini]\n    δ_collection = Float64[]\n    δ = step_size\n\n    # initialize variables for Newton's method\n    Df = Matrix{Float64}(undef, n-1, n)\n    v = vec(nullspace(Df!(Df, x_ini)))\n    w = Vector{Float64}(undef, n)\n    x = Vector{Float64}(undef, n)\n    F = Vector{Float64}(undef, n)\n    DF = Matrix{Float64}(undef, n, n)\n\n    # initialize variables for the proof\n    R = 1e-2\n    s = Interval(0.0, 1.0)\n    Df_interval = Matrix{Interval{Float64}}(undef, n-1, n)\n    v_interval = Vector{Interval{Float64}}(undef, n)\n    x₀_interval = Vector{Interval{Float64}}(undef, n)\n    x₀R_interval = Vector{Interval{Float64}}(undef, n)\n    F_interval = Vector{Interval{Float64}}(undef, n)\n    DF_interval = Matrix{Interval{Float64}}(undef, n, n)\n    Ω₁ = Vector{Interval{Float64}}(undef, n)\n    Ω₂ = Matrix{Interval{Float64}}(undef, n, n)\n\n    k = 1\n    while k ≤ max_iter && δ ≥ 1e-8\n        w .= x_collection[end] .+ δ .* v\n        x .= w\n        x, success = newton!(F_DF_NewtonPseudoArclength!(w, v),\n            x, F, DF;\n            tol = 1e-15, verbose = false)\n        if success\n            v_ = v\n            v = vec(nullspace(Df!(Df, x)))\n            if v ⋅ v_ < 0\n                v .= (-).(v)\n            end\n            if v == v_\n                v_interval .= Interval.(v_)\n            else\n                v_interval .= v_ .+ s .* Interval.(v .- v_)\n            end\n            x₀_interval .= Interval.(x_collection[end]) .+ s .* (Interval.(x) .- Interval.(x_collection[end]))\n            x₀R_interval .= Interval.(inf.(x₀_interval .- R), sup.(x₀_interval .+ R))\n            F_DF_ProofPseudoArclength!(F_interval, DF_interval, x₀_interval, x₀R_interval, v_interval)\n            DF .= mid.(DF_interval)\n            A = inv(DF)\n\n            Ω₁ .= Interval.(mag.(A * F_interval))\n            Ω₂ .= Interval.(mag.(A * DF_interval - I))\n            Y = norm(Ω₁, Inf)\n            Z₁ = opnorm(Ω₂, Inf)\n            ie = interval_of_existence(Y, Z₁, R)\n            if isempty(ie)\n                δ /= 2\n            else\n                push!(x_collection, copy(x))\n                push!(δ_collection, δ)\n                push!(ie_collection, ie)\n                δ *= 2\n            end\n        else\n            δ /= 2\n        end\n        k += 1\n    end\n\n    return x_collection, δ_collection, ie_collection\nend\n\nstruct F_DF_NewtonPseudoArclength!\n    w :: Vector{Float64}\n    v :: Vector{Float64}\nend\n\nfunction (F_DF!::F_DF_NewtonPseudoArclength!)(F, DF, x)\n    n = length(x)\n    F[1] = (x - F_DF!.w) ⋅ F_DF!.v\n    f!(view(F, 2:n), x)\n    DF[1,:] .= F_DF!.v\n    Df!(view(DF, 2:n, :), x)\n    return F, DF\nend\n\nfunction F_DF_ProofPseudoArclength!(F, DF, x, xR, v)\n    n = length(x)\n    F[1] = 0\n    f!(view(F, 2:n), x)\n    DF[1,:] .= v\n    Df!(view(DF, 2:n, :), xR)\n    return F, DF\nend\n\n# in-place FitzHugh-Nagumo model\n\nfunction f!(f, x)\n    a, ϵ = 5, 1\n    γ, u₁, u₂ = x\n    f[1] = u₁*(u₁ - a)*(1 - u₁) - u₂\n    f[2] = ϵ*(u₁ - γ*u₂)\n    return f\nend\n\nfunction Df!(Df, x)\n    a, ϵ = 5, 1\n    γ, u₁, u₂ = x\n    Df[1,1] = 0\n    Df[1,2] = a*(2u₁ - 1) + (2 - 3u₁)*u₁\n    Df[1,3] = -1\n    Df[2,1] = -ϵ*u₂\n    Df[2,2] = ϵ\n    Df[2,3] = -ϵ*γ\n    return Df\nend\n\nx, δ, ie = rigorous_pseudo_arclength([2, 1.129171306613029, 0.564585653306514], 0.1, 3_000)","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"The following figure shows the numerical approximation of the branch of equilibria for the FitzHugh-Nagumo model.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"(Image: )","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"The following figure shows the sharpest computed a posteriori error bound for each numerical approximation of a piece of the branch of equilibria for the FitzHugh-Nagumo model.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"(Image: )","category":"page"},{"location":"#Presentation","page":"Home","title":"Presentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The solution of many problems in dynamical systems can be seen as the fixed point of an operator. In computer-assisted proofs, the Radii Polynomial Theorem gives us closed ball(s), centred at a numerical approximation of the fixed point, within which the operator satisfies the Banach Fixed Point Theorem.[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: For Newton-like operators, the Radii Polynomial Theorem is an instance of the Newton-Kantorovich Theorem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hence, the desired solution is the unique fixed point within the ball(s) whose radius yields an a posteriori error bound on the numerical approximation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"RadiiPolynomial.jl is a Julia package to conduct the computational steps of the Radii Polynomial Theorem which entails rigorous arithmetic (cf. IntervalArithmetic.jl).","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the solution lies in a Banach space involving function spaces, the standard approach is to interpret the function spaces as sequence spaces. Thus, RadiiPolynomial is concerned with the latter (cf. ApproxFun.jl for a Julia package to approximate functions).","category":"page"},{"location":"#Installing","page":"Home","title":"Installing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, use the following command inside the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"RadiiPolynomial\")","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use the RadiiPolynomial software in your publication, research, teaching, or other activities, please use the following BibTeX template (cf. CITATION.bib):","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{RadiiPolynomial.jl,\n  author = {Olivier Hénot},\n  title  = {RadiiPolynomial.jl},\n  url    = {https://github.com/OlivierHnt/RadiiPolynomial.jl},\n  year   = {},\n  doi    = {}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"The empty fields year and doi should correspond with the cited version of the RadiiPolynomial software. For instance, if you wish to cite the software as a whole: year = {2021} and doi = {10.5281/zenodo.5705258}.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You may refer to 10.5281/zenodo.5705258 for more informations.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/#Spiderweb-central-configurations","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"","category":"section"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"In this example, we will prove the existence and local uniqueness of a central configuration in the N-body problem.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"More precisely, we will look at configurations given by N = n times ell+1 masses located at the intersection points of ell concurrent equidistributed half-lines with n circles and a central mass m_0. The ell masses on the i-th circle are equal to a positive constant m_i and we allow the particular case m_0 = 0. These central configurations are called spiderweb central configurations.[1]","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"[1]: O. Hénot and C. Rousseau, Spiderweb central configurations, Qualitative Theory of Dynamical Systems, 18 (2019), 1135–1160.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"The N-body problem consists in describing the positions mathbfr_1(t)dotsmathbfr_N(t) of N masses m_1dotsm_N interacting through Newton's gravitational law:","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"m_i fracd^2dt^2 mathbfr_i\n=\n-sum_jneq i fracG m_i m_j(mathbfr_i - mathbfr_j) mathbfr_i - mathbfr_j ^3\n=\n-fracpartialpartial mathbfr_i U (mathbfr)\nqquad\nU (mathbfr)\n=\n-sum_ij fracG m_i m_jmathbfr_i-mathbfr_j","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"for i = 1dotsN, with mathbfr in  (mathbfr_1dotsmathbfr_N) in R^3N    mathbfr_i neq mathbfr_j    i neq j, where G denotes the gravitational constant.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"In the following, we fix the centre of mass at the origin and scale G = 1. Moreover, due to the symmetries of a spiderweb central configuration, it is sufficient to consider the accelerations of the n bodies on the positive horizontal axis, and the numbers r_1 dots r_n also denote the positions of the masses on this semi-axis.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"The configuration of N bodies is central at some time t^* if fracd^2dt^2mathbfr(t^*) = lambda mathbfr(t^*) for some common lambda. It is easy to see that lambda is a strictly negative value given by lambda = U(mathbfr)I(mathbfr)  0 where I = sum_i = 1^N m_i mathbfr_i(mathbfr)^2 is the moment of inertia. Essentially, the value of lambda scales the system and can be chosen arbitrarily.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"Then, the original system of ODEs reduces to the following system of equations in mathbbR^n:","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"lambda r_i\n=\n-sum_k=1^ell-1 fracm_i 2^32r_i^2( 1 - cos theta_k )^12 -frac m_0 r_i^2 - sum_beginsmallmatrixj=1jneq i endsmallmatrix^n sum_k=0^ell-1 fracm_j( r_i - r_j cos theta_k )( r_i^2 + r_j^2 - 2 r_i r_j cos theta_k )^32","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"for i = 1 dots n, with theta_k = frac2pi kell and r = (r_1dotsr_n) in  r in R^n    0  r_1  ldots  r_n.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"Thus, a spiderweb central configuration is a zero of the mapping F = (F_1 dots F_n)  mathbbR^n to mathbbR^n given by","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"F_i(r) =\nlambda  r_i + frac m_i 2^32r_i^2zeta_ell + frac m_0r_i^2 + sum_beginsmallmatrixj=1jneq i endsmallmatrix^n sum_k=0^ell-1 fracm_j( r_i - r_j cos theta_k )( r_i^2 + r_j^2 - 2 r_i r_j cos theta_k )^32  qquad i =1 dots n","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"where zeta_ell = sum_k=1^ell-1 (1-cos theta_k)^-12.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"The Jacobian matrix is given by","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"fracpartialpartial r_j F_i(r) =\nbegincases\ndisplaystyle lambda - frac m_i r_i^3sqrt2zeta_ell - frac 2m_0 r_i^3\n-sum_beginsmallmatrixj=1jneq i endsmallmatrix^n fracm_j2sum_k=0^ell-1\nfrac4r_i^2+r_j^2-8 r_i r_j cos theta_k + 3 r_j^2 cos 2theta_k( r_i^2 + r_j^2 - 2 r_i r_j cos theta_k )^52 j=i\ndisplaystyle -fracm_j2 sum_k=0^ell-1\nfrac-4(r_i^2+r_j^2)cos theta_k + r_i r_j (7+ cos 2theta_k)( r_i^2 + r_j^2 - 2 r_i r_j cos theta_k)^52  jneq i\nendcases","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"Consider the fixed-point operator T  mathbbR^n to mathbbR^n defined by","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"T(x) = x - A F(x)","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"where A  mathbbR^n to mathbbR^n is the injective operator corresponding to a numerical approximation of DF(x_0)^-1 for some numerical zero x_0 in mathbbR^n of F.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"Let R  0. According to the first-order Radii Polynomial Theorem, we need to estimate T(x_0) - x_0_infty and sup_y in textcl( B_R(x_0) ) DT(y)_infty which can be readily computed with interval arithmetic.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"We can now write our computer-assisted proof:","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"using RadiiPolynomial\n\nfunction F_DF!(F::Vector{T}, DF::Matrix{T}, x::Vector{T}, xR::Vector{T}, m₀::T, m::Vector{T}, λ::T, n::Int, l::Int) where {T}\n    length(F) == size(DF, 1) == size(DF, 2) == length(x) == length(xR) == length(m) || return throw(DimensionMismatch)\n    π2_l = 2convert(T, π)/l\n    sqrt2 = sqrt(convert(T, 2))\n    DF .= Matrix{T}(I*λ, n, n)\n    @inbounds for j ∈ axes(DF, 2)\n        xⱼ² = x[j]*x[j]\n        xRⱼ² = xR[j]*xR[j]\n        @inbounds for i ∈ axes(DF, 1)\n            xᵢ², xᵢxⱼ = x[i]*x[i], x[i]*x[j]\n            xRᵢ², xRᵢxRⱼ = xR[i]*xR[i], xR[i]*xR[j]\n            xRᵢ³ = xRᵢ²*xR[i]\n            if j == 1\n                F[i] = λ*x[i] + m₀/xᵢ²\n            end\n            if i == j\n                DF[i,j] -= 2m₀/xRᵢ³\n            end\n            @inbounds for k ∈ 0:l-1\n                θ = k*π2_l\n                cosθ = cos(θ)\n                cos2θ = cos(2θ)\n                if i ≠ j\n                    d = sqrt(xᵢ² + xⱼ² - 2xᵢxⱼ*cosθ)\n                    dᵣ = sqrt(xRᵢ² + xRⱼ² - 2xRᵢxRⱼ*cosθ)\n                    dᵣ⁵2 = 2dᵣ*dᵣ*dᵣ*dᵣ*dᵣ\n                    F[i] += m[j]*(x[i] - x[j]*cosθ)/(d*d*d)\n                    DF[i,i] -= m[j]*(4xRᵢ² + xRⱼ² - 8xRᵢxRⱼ*cosθ + 3xRⱼ²*cos2θ)/dᵣ⁵2\n                    DF[i,j] -= m[j]*(-4(xRᵢ² + xRⱼ²)*cosθ + xRᵢxRⱼ*(7 + cos2θ))/dᵣ⁵2\n                elseif i == j && k > 0\n                    ζ = sqrt2*sqrt(1-cosθ)\n                    F[i] += m[i]/(2xᵢ²*ζ)\n                    DF[i,j] -= m[i]/(xRᵢ³*ζ)\n                end\n            end\n        end\n    end\n    return F, DF\nend\n\nn = 18 # number of circles\nl = 100 # number of masses per circle\n\n# numerical solution\n\nm₀ = 0.0 # central mass\nm = fill(1/l, n) # vector of masses\nλ = -1.0\n\nx₀ = float.(1:n)\nF = Vector{Float64}(undef, n)\nDF = Matrix{Float64}(undef, n, n)\nnewton!((F, DF, x) -> F_DF!(F, DF, x, x, m₀, m, λ, n, l),\n    x₀, F, DF;\n    tol = 1e-12, maxiter = 50, verbose = false)\nsort!(x₀)\n\n# proof\n\nm₀_interval = Interval(0.0)\nm_interval = fill(@interval(1/l), n)\nλ_interval = Interval(-1.0)\n\nR = 1e-12\n\nx₀_interval = Interval.(x₀)\nx₀R_interval = Interval.(inf.(x₀_interval .- R), sup.(x₀_interval .+ R))\nF_interval = Vector{Interval{Float64}}(undef, n)\nDF_interval = Matrix{Interval{Float64}}(undef, n, n)\nF_DF!(F_interval, DF_interval, x₀_interval, x₀R_interval, m₀_interval, m_interval, λ_interval, n, l)\nA = inv(mid.(DF_interval))\n\nY = norm(Interval.(mag.(A * F_interval)), Inf)\nZ₁ = opnorm(Interval.(mag.(A * DF_interval - I)), Inf)\nshowfull(interval_of_existence(Y, Z₁, R))","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"The following figure shows the numerical approximation of the spiderweb central configuration.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"(Image: )","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"using RadiiPolynomial","category":"page"},{"location":"sequence_spaces/sequences/#Sequences","page":"Sequences","title":"Sequences","text":"","category":"section"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"A Sequence is a structure representing a sequence in a prescribed VectorSpace. More precisely, a Sequence is comprised of the two fields space::VectorSpace and coefficients::AbstractVector with matching dimension and length.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"a = Sequence(Taylor(1), [1, 2])","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The two fields space and coefficients are accessible via the respective functions of the same name.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"space(a)\ncoefficients(a)","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The coefficients of a Sequence are indexed according to the indices of the space (as given by indices).","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"a[0:1] # indices(space(a))","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"When the space of a Sequence is a CartesianSpace, its coefficients are given as the concatenation of the coefficients associated with each space. The function component extracts a Sequence composing the cartesian space.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"b = Sequence(ParameterSpace() × Taylor(1)^2, [1, 2, 3, 4, 5])\nb[1:5] # indices(space(b))\ncomponent(b, 1) # extract the sequence associated with the space ParameterSpace()\ncomponent(b, 2) # extract the sequence associated with the space Taylor(1)^2\ncomponent(component(b, 2), 1)\ncomponent(component(b, 2), 2)","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"Similarly, the function eachcomponent returns a Generator whose iterates yield the each Sequence composing the cartesian space.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"Sequence","category":"page"},{"location":"sequence_spaces/sequences/#RadiiPolynomial.Sequence","page":"Sequences","title":"RadiiPolynomial.Sequence","text":"Sequence{T<:VectorSpace,S<:AbstractVector}\n\nCompactly supported sequence of the given space.\n\nFields:\n\nspace :: T\ncoefficients :: S\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/sequences/#Arithmetic","page":"Sequences","title":"Arithmetic","text":"","category":"section"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The addition and subtraction operations are implemented as the + and - functions respectively. Their bar counterparts +̄ (+\\bar<TAB>) and -̄ (-\\bar<TAB>) give the result projected in the smallest compatible space between the operands.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"c = Sequence(Taylor(1), [0, 1])\nd = Sequence(Taylor(2), [1, 2, 1])\nc + d\nc - d\nc +̄ d # project(c + d, Taylor(1))\nc -̄ d # project(c - d, Taylor(1))","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The discrete convolution between sequences whose spaces are a SequenceSpace is implemented as the * and ^ functions. Their bar counterparts *̄ (*\\bar<TAB>) and ^̄ (^\\bar<TAB>) give the result projected in the smallest compatible space between the operands; in general, *̄ is not associative.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"c * d\nc ^ 3\nc *̄ d # project(c * d, Taylor(1))\nc ^̄ 3 # project(c ^ 3, Taylor(1))","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"To improve performance, the FFT algorithm may be used to compute discrete convolutions via the Convolution Theorem. However, the performance gain is tempered with the loss of accuracy which may stop the decay of the coefficients.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"x = Sequence(Taylor(3), Interval.([inv(10_000.0 ^ i) for i ∈ 0:3]))\nx³ = x ^ 3\nx³_fft = rifft!(similar(x³), fft(x, fft_size(space(x), 3)) .^ 3)","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"To circumvent machine precision limitations, the banach_rounding! method enclose rigorously each term of the convolution beyond a prescribed order.[1]","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"[1]: J.-P. Lessard, Computing discrete convolutions with verified accuracy via Banach algebras and the FFT, Applications of Mathematics, 63 (2018), 219-235.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The rounding strategy for *, ^, *̄ and ^̄ is integrated in the functions banach_rounding_mul, banach_rounding_pow, banach_rounding_mul_bar and banach_rounding_pow_bar respectively.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"weights = GeometricWeights(Interval(10_000.0))\nnorm_x = norm(x, Weightedℓ¹(weights))\nbanach_rounding!(x³_fft, weights, norm_x ^ 3, 5)","category":"page"}]
}
