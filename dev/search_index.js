var documenterSearchIndex = {"docs":
[{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"using RadiiPolynomial","category":"page"},{"location":"sequence_spaces/linear_operators/#Linear-operators","page":"Linear operators","title":"Linear operators","text":"","category":"section"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"A LinearOperator is a structure representing a linear operator from a VectorSpace to an other. More precisely, a LinearOperator is comprised of the three fields domain::VectorSpace, codomain::VectorSpace and coefficients::AbsractMatrix with matching dimensions and size.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"A = LinearOperator(Taylor(1), Taylor(1), [1 2 ; 3 4])","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The three fields domain, codomain and coefficients are accessible via the respective functions of the same name.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"domain(A)\ncodomain(A)\ncoefficients(A)","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The coefficients of a LinearOperator are indexed according to the indices of the domain and codomain (as given by indices).","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"A[0:1,0:1] # indices(domain(A)), indices(codomain(A))","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"When the domain and/or the codomain of a LinearOperator is a CartesianSpace, its coefficients can be thought of as a block matrix . The function component extracts a LinearOperator composing the cartesian space.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"B = LinearOperator(ParameterSpace() Ã— Taylor(1)^2, ParameterSpace() Ã— Taylor(1)^2, reshape(1:25, 5, 5))\nB[1:5,1:5] # indices(domain(B)), indices(codomain(B))\ncomponent(B, 1, 1) # extract the linear operator associated with the domain ParameterSpace() and codomain ParameterSpace()\ncomponent(B, 2, 2) # extract the linear operator associated with the domain Taylor(1)^2 and codomain Taylor(1)^2\ncomponent(component(B, 2, 2), 1, 1)\ncomponent(component(B, 2, 2), 2, 2)","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"Similarly, the function eachcomponent returns a Generator whose iterates yield each LinearOperator composing the cartesian space.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"LinearOperator","category":"page"},{"location":"sequence_spaces/linear_operators/#RadiiPolynomial.LinearOperator","page":"Linear operators","title":"RadiiPolynomial.LinearOperator","text":"LinearOperator{T<:VectorSpace,S<:VectorSpace,R<:AbstractMatrix}\n\nCompactly supported operator with effective domain and codomain.\n\nFields:\n\ndomain :: T\ncodomain :: S\ncoefficients :: R\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/linear_operators/#Arithmetic","page":"Linear operators","title":"Arithmetic","text":"","category":"section"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The addition and subtraction operations are implemented as the + and - functions respectively. Their bar counterparts +Ì„ (+\\bar<TAB>) and -Ì„ (-\\bar<TAB>) give the result projected in the smallest compatible domain and codomain between the operands.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"C = LinearOperator(Taylor(1), Taylor(1), [1 2 ; 3 4])\nD = LinearOperator(Taylor(1), Taylor(2), [1 2 ; 3 4 ; 5 6])\nC + D\nC - D\nC +Ì„ D # project(C + D, Taylor(1), Taylor(1))\nC -Ì„ D # project(C - D, Taylor(1), Taylor(1))\nC + I\nC - I","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The product between LinearOperator is implemented as the *, or equivalently âˆ˜, and ^ functions. The division between LinearOperator is implemented as the \\ method.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"C * D # C âˆ˜ D\nC ^ 3\nC \\ C","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"The action of a LinearOperator is performed by the right product * of a LinearOperator with a Sequence; alternatively, LinearOperator defines a method on a Sequence representing *. Naturally, the resulting sequence is an element of the codomain of the LinearOperator.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"Conversely, the operator \\ between a LinearOperator and a Sequence corresponds to the action of the inverse of the LinearOperator; the output sequence is an element of the domain of the LinearOperator.","category":"page"},{"location":"sequence_spaces/linear_operators/","page":"Linear operators","title":"Linear operators","text":"x = Sequence(Taylor(2), [1, 1, 1])\nC * x # C(x)\nD \\ x","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"using RadiiPolynomial","category":"page"},{"location":"sequence_spaces/norms/#Norms","page":"Norms","title":"Norms","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The spaces introduced in the section Vector spaces are not normed a priori. Indeed, to satisfy the Radii Polynomial Theorem, it is useful to tune the Banach space by adjusting its norm on the fly.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"RadiiPolynomial defines norms which are known to turn a VectorSpace into a Banach space or a Banach algebra.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"All norms mentioned below are a subtype of the abstract type Norm.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Norm\nâ”œâ”€ CartesianPowerNorm\nâ”œâ”€ CartesianProductNorm\nâ”œâ”€ Weightedâ„“Â¹Norm\nâ”œâ”€ â„“áµ–Norm\nâ””â”€ ğ»Ë¢Norm","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Norm","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.Norm","page":"Norms","title":"RadiiPolynomial.Norm","text":"Norm\n\nAbstract type for all norms.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#\\ellp-norm","page":"Norms","title":"ell^p norm","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Let mathscrI be a set of indices such that mathscrI subset mathbbZ^d for some d in mathbbN and p in 1 +infty) cup  +infty . The ell^p space is defined as","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"ell^p = left a in mathbbC^mathscrI    +infty   a _ell^p =\nbegincases\nleft( sum_alpha in mathscrI  a_alpha  ^ p right)^1p  1 leq p  +infty\nsup_alpha in mathscrI  a_alpha   p = +infty\nendcases right","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The â„“áµ–Norm (\\ell<TAB>\\^p<TAB>Norm) wraps such a p.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(2), [1.0, 2.0, 3.0])\nnorm(a, â„“áµ–Norm(Inf))","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"â„“áµ–Norm","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.â„“áµ–Norm","page":"Norms","title":"RadiiPolynomial.â„“áµ–Norm","text":"â„“áµ–Norm{T<:Real} <: Norm\n\nNorm of the ell^p space.\n\nFields:\n\np :: T\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#Weighted-\\ell1-norm","page":"Norms","title":"Weighted ell^1 norm","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The Weightedâ„“Â¹Norm (Weighted\\ell<TAB>\\^1<TAB>Norm) represents the norm for a weighted ell^1 space.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Weightedâ„“Â¹Norm","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.Weightedâ„“Â¹Norm","page":"Norms","title":"RadiiPolynomial.Weightedâ„“Â¹Norm","text":"Weightedâ„“Â¹Norm{T<:Union{Weights,Tuple{Vararg{Weights}}}} <: Norm\n\nNorm of the weighted ell^1 space.\n\nFields:\n\nweights :: T\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#Geometric-weights","page":"Norms","title":"Geometric weights","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Let mathscrI be a set of indices such that mathscrI subset mathbbZ^d for some d in mathbbN.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The geometric weights of rate nu  0 are the numbers nu^alpha for all alpha in mathscrI. The corresponding weighted ell^1 space is defined as","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"ell^1_nu = left a in mathbbC^mathscrI    +infty   a _ell^1_nu = sum_alpha in mathscrI a_alpha nu^alpha right","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(2), [1.0, 2.0, 3.0])\nnorm(a, Weightedâ„“Â¹Norm(GeometricWeights(2.0)))","category":"page"},{"location":"sequence_spaces/norms/#Algebraic-weights","page":"Norms","title":"Algebraic weights","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Let mathscrI be a set of indices such that mathscrI subset mathbbZ^d for some d in mathbbN.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The algebraic weights of rate s geq 0 are the numbers (1 + alpha)^s for all alpha in mathscrI. The corresponding weighted ell^1 space is defined as","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"ell^1_s = left a in mathbbC^mathscrI    +infty   a _ell^1_s = sum_alpha in mathscrI a_alpha (1 + alpha)^s right","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(2), [1.0, 2.0, 3.0])\nnorm(a, Weightedâ„“Â¹Norm(AlgebraicWeights(2.0)))","category":"page"},{"location":"sequence_spaces/norms/#Hs-norm","page":"Norms","title":"H^s norm","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"Let mathscrI be a set of indices such that mathscrI subset mathbbZ^d for some d in mathbbN and s in 1 +infty). The Sobolev space H^s is defined as","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"H^s = left a in mathbbC^mathscrI    +infty   a _H^s = left( sum_alpha in mathscrI  a_alpha  left( 1 + sum_i=1^d  alpha_i ^2 right)^s right)^12 right","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"The ğ»Ë¢Norm (\\itH<TAB>\\^s<TAB>Norm) wraps such a s.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Fourier(1, 1.0), [0.5, 0.0, 0.5])\nnorm(a, ğ»Ë¢Norm(2.0))","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"ğ»Ë¢Norm","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.ğ»Ë¢Norm","page":"Norms","title":"RadiiPolynomial.ğ»Ë¢Norm","text":"ğ»Ë¢Norm{T<:Real} <: Norm\n\nNorm of the H^s Sobolev space.\n\nFields:\n\nexponent :: T\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#Cartesian-norms","page":"Norms","title":"Cartesian norms","text":"","category":"section"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"One may use:","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"CartesianPowerNorm to use the same norm for each space constituting a CartesianSpace.\nCartesianProductNorm to use a different norm for each space constituting a CartesianSpace.","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"a = Sequence(Taylor(1)^2 Ã— Chebyshev(1)^2, [1, 2, 3, 4, 5, 6, 7, 8])\ninner_norm = CartesianProductNorm((Weightedâ„“Â¹Norm(GeometricWeights(2.0)), Weightedâ„“Â¹Norm(AlgebraicWeights(3.0))), â„“áµ–Norm(Inf))\nnorm(c, CartesianPowerNorm(inner_norm, â„“áµ–Norm(1)))","category":"page"},{"location":"sequence_spaces/norms/","page":"Norms","title":"Norms","text":"CartesianPowerNorm\nCartesianProductNorm","category":"page"},{"location":"sequence_spaces/norms/#RadiiPolynomial.CartesianPowerNorm","page":"Norms","title":"RadiiPolynomial.CartesianPowerNorm","text":"CartesianPowerNorm{T<:Norm,S<:Norm} <: Norm\n\nNorm of a cartesian space comprised of spaces with the same norm.\n\nFields:\n\ninner :: T\nouter :: S\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/norms/#RadiiPolynomial.CartesianProductNorm","page":"Norms","title":"RadiiPolynomial.CartesianProductNorm","text":"CartesianProductNorm{T<:Tuple{Vararg{Norm}}, S<:Norm} <: Norm\n\nNorm of a cartesian space comprised of spaces with different norms.\n\nFields:\n\ninner :: T\nouter :: S\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/special_operators/#Special-operators","page":"Special operators","title":"Special operators","text":"","category":"section"},{"location":"sequence_spaces/special_operators/#Projection","page":"Special operators","title":"Projection","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nA = LinearOperator(Taylor(1) âŠ— Chebyshev(1), Taylor(1) âŠ— Chebyshev(1), [1.0 0.0 0.0 0.0 ; 0.0 1.0 0.0 0.0 ; 0.0 0.0 1.0 0.0 ; 0.0 0.0 0.0 1.0])\nproject(A, Taylor(1) âŠ— Chebyshev(2), Taylor(2) âŠ— Chebyshev(1), Float64)","category":"page"},{"location":"sequence_spaces/special_operators/#Multiplication","page":"Special operators","title":"Multiplication","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nA = Multiplication(Sequence(Taylor(1) âŠ— Fourier(1, 1.0), [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]))\nproject(A, Taylor(1) âŠ— Fourier(1, 1.0), Taylor(2) âŠ— Fourier(0, 1.0), Float64)","category":"page"},{"location":"sequence_spaces/special_operators/#Derivation-and-integration","page":"Special operators","title":"Derivation and integration","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Derivative(1), Taylor(2), Taylor(1), Float64)\nproject(Derivative((1, 1)), Taylor(2) âŠ— Fourier(1, 1.0), Taylor(1) âŠ— Fourier(1, 1.0), Complex{Float64})","category":"page"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Integral(1), Taylor(2), Taylor(3), Float64)\nproject(Integral((1, 1)), Taylor(1) âŠ— Fourier(1, 1.0), Taylor(2) âŠ— Fourier(1, 1.0), Complex{Float64})","category":"page"},{"location":"sequence_spaces/special_operators/#Evaluation","page":"Special operators","title":"Evaluation","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Evaluation(0.5), Taylor(2), Taylor(0), Float64)\nproject(Evaluation((0.5, nothing)), Taylor(2) âŠ— Fourier(1, 1.0), Taylor(0) âŠ— Fourier(1, 1.0), Float64)","category":"page"},{"location":"sequence_spaces/special_operators/#Scale","page":"Special operators","title":"Scale","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Scale(2.0), Taylor(2), Taylor(2), Float64)\nproject(Scale((2.0, nothing)), Taylor(2) âŠ— Fourier(1, 1.0), Taylor(2) âŠ— Fourier(1, 1.0), Float64)","category":"page"},{"location":"sequence_spaces/special_operators/#Shift","page":"Special operators","title":"Shift","text":"","category":"section"},{"location":"sequence_spaces/special_operators/","page":"Special operators","title":"Special operators","text":"using RadiiPolynomial\nproject(Shift(Ï€/2), Fourier(1, 1.0), Fourier(1, 1.0), Complex{Float64})","category":"page"},{"location":"radii_polynomial_theorem/#Radii-Polynomial-Theorem","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"","category":"section"},{"location":"radii_polynomial_theorem/","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"Let X be a Banach space, U an open subset of X, k in mathbbN, T in C^k(U X), x_0 in U and R geq 0 such that textcl( B_R(x_0) ) subset U. Suppose Y Z_1 dots Z_k geq 0 satisfy","category":"page"},{"location":"radii_polynomial_theorem/","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"beginaligned\nY geq T(x_0) - x_0_X\nZ_i geq D^i T(x_0)_mathscrB(X^i X) qquad i = 1 dots k-1\nZ_k geq sup_y in textcl( B_R(x_0) ) D^k T(y)_mathscrB(X^k X)\nendaligned","category":"page"},{"location":"radii_polynomial_theorem/","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"and define the radii polynomial by","category":"page"},{"location":"radii_polynomial_theorem/","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"p(r) = Y - r + sum_i = 1^k fracZ_ii r^i","category":"page"},{"location":"radii_polynomial_theorem/","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"The Radii Polynomial Theorem states that if p(r_0) leq 0 and fracr_0^k-1(k-1) Z_k  1 for some r_0 in 0 R, then T satisfies the Banach Fixed Point Theorem in the closed ball textcl( B_r_0 (x_0) ); the set of all possible radii is called the interval of existence.","category":"page"},{"location":"radii_polynomial_theorem/","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"In practice, p is linear or quadratic and the interval of existence consists in a segment of the positive real line.","category":"page"},{"location":"radii_polynomial_theorem/","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"The infimum of the interval of existence gives the sharpest computed a posteriori error bound on x_0. The supremum of the interval of existence represents the largest computed radius of the ball centred at x_0 within which the solution is unique.","category":"page"},{"location":"radii_polynomial_theorem/","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"The interval_of_existence method returns the Interval such that p is negative.","category":"page"},{"location":"radii_polynomial_theorem/","page":"Radii Polynomial Theorem","title":"Radii Polynomial Theorem","text":"interval_of_existence","category":"page"},{"location":"radii_polynomial_theorem/#RadiiPolynomial.interval_of_existence","page":"Radii Polynomial Theorem","title":"RadiiPolynomial.interval_of_existence","text":"interval_of_existence(Y::Interval{T}, Zâ‚::Interval{T}, R::T) where {T<:Real}\n\nReturn the interval of existence associated with the polynomial Y + (Z_1 - 1)r.\n\n\n\n\n\ninterval_of_existence(Y::Interval{T}, Zâ‚::Interval{T}, Zâ‚‚::Interval{T}, R::T) where {T<:Real}\n\nReturn the interval of existence associated with the polynomial Y + (Z_1 - 1)r + Z_2 r^2  2.\n\n\n\n\n\n","category":"function"},{"location":"examples/infinite_dimensional_proofs/ivp/#Initial-value-problem-for-Ordinary-Differential-Equations-(ODE)","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"","category":"section"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"In this example, we will prove the existence of a solution of the initial value problem","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"begincases\ndisplaystyle fracddt u(t) = f(u(t)) = u(t)^2 - u(t)\nu(0) = 12\nendcases","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"Let nu  0 and X = (ell^1_nu *) where","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"ell^1_nu = left  x_alpha _alpha geq 0 in mathbbR^mathbbN cup 0     x _ell^1_nu = sum_alpha geq 0 x_alpha nu^alpha  +infty right","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"and *  ell^1_nu times ell^1_nu to ell^1_nu is the Cauchy product given by","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"x * y = left sum_beta = 0^alpha x_alpha - beta y_beta right_alpha geq 0 qquad textfor all  x y in ell^1_nu","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"The Banach algebra X is a suitable space to look for a solution of the initial value problem. Indeed, it is a standard result from ODE theory that analytic vector fields yield analytic solutions. For any sequence x in X, the series sum_alpha geq 0 x_alpha t^alpha defines an analytic function in C^omega(-nu nu mathbbR); while the Cauchy product * corresponds to the product of analytic functions in sequence space.[1]","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"[1]: A. Hungria, J.-P. Lessard and J. D. Mireles James, Rigorous numerics for analytic solutions of differential equations: the radii polynomial approach, Mathematics of Computation, 85 (2016), 1427-1459.","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"It follows that the sequence of coefficients of a Taylor series solving the initial value problem is a zero of the mapping F  X to X given component-wise by","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"( F(x) )_alpha =\nbegincases\nx_0 - 12  alpha = 0\nalpha x_alpha - (x*x - x)_alpha-1  alpha geq 1\nendcases","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"Consider the fixed-point operator T  X to X defined by","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"T(x) = x - A F(x)","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"where A  X to X is the injective operator corresponding to a numerical approximation of DF(x_0)^-1 for some numerical zero x_0 in X of F.","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"Let R  0. According to the Radii Polynomial Theorem, we need to estimate T(x_0) - x_0_X, DT(x_0)_mathscrB(X X) and sup_y in textcl( B_R(x_0) ) D^2T(y)_mathscrB(X^2 X).","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"To this end, for all x in X, consider the projection operators","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"beginaligned\n(pi^n x)_alpha = begincases x_alpha  alpha leq n  0  alpha  n endcases\npi^infty(n) x = x - pi^n x\nendaligned","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"Thus, for all x_0 in X and R  0, we have","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"beginaligned\nT(x_0) - x_0_X leq pi^n A pi^n F(x_0)_X + frac1n+1 pi^infty(n) F(x_0)_X\nDT(x_0)_mathscrB(X X) leq pi^n A pi^n DF(x_0) pi^n - I_mathscrB(X X) + fracnun+1 2x_0 - 1_X\nsup_y in textcl( B_R(x_0) ) D^2T(y)_mathscrB(X^2 X) leq 2 nu left( pi^n A pi^n_mathscrB(X X) + frac1n+1 right)\nendaligned","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"In particular, from the latter estimate, we may freely choose R = infty.","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"We can now write our computer-assisted proof:","category":"page"},{"location":"examples/infinite_dimensional_proofs/ivp/","page":"Initial value problem for Ordinary Differential Equations (ODE)","title":"Initial value problem for Ordinary Differential Equations (ODE)","text":"using RadiiPolynomial\n\nfunction F(x::Sequence{Taylor})\n    f = x^2 - x\n    F_ = Sequence(Taylor(order(f)+1), Vector{eltype(x)}(undef, length(f)+1))\n    F_[0] = x[0] - 0.5\n    F_[1:end] .= Derivative(1) * x - f\n    return F_\nend\n\nfunction DF(x::Sequence{Taylor}, domain::Taylor, codomain::Taylor, ::Type{CoefType}) where {CoefType}\n    DF_ = LinearOperator(domain, codomain, zeros(CoefType, dimension(codomain), dimension(domain)))\n    DF_[0,0] = one(CoefType)\n    DF_[1:end,:] .=\n        project(Derivative(1), domain, Taylor(order(codomain)-1), CoefType) .-\n        project(Multiplication(2x - 1), domain, Taylor(order(codomain)-1), CoefType)    \n    return DF_\nend\n\n# numerical solution\n\nn = 27\nxâ‚€ = Sequence(Taylor(n), zeros(n+1))\nxâ‚€, success = newton(x -> (project(F(x), space(x)), DF(x, space(x), space(x), eltype(x))),\n    xâ‚€;\n    verbose = false)\n\n# proof\n\nxâ‚€_interval = Interval.(xâ‚€)\nF_interval = F(xâ‚€_interval)\ntail_F_interval = copy(F_interval)\ntail_F_interval[0:n] .= Interval(0.0)\nDF_interval = DF(xâ‚€_interval, space(xâ‚€_interval), space(xâ‚€_interval), eltype(xâ‚€_interval))\nA = inv(mid.(DF_interval))\nbound_tail_A = inv(Interval(n+1))\n\nÎ½ = Interval(1.0)\nmetric = Weightedâ„“Â¹Norm(GeometricWeights(Î½))\nR = Inf\n\nY = norm(A * F_interval, metric) + bound_tail_A * norm(tail_F_interval, metric)\nZâ‚ = opnorm(A * DF_interval - I, metric) + bound_tail_A * Î½ * norm(2xâ‚€_interval - 1, metric)\nZâ‚‚ = 2Î½ * (opnorm(A, metric) + bound_tail_A)\nshowfull(interval_of_existence(Y, Zâ‚, Zâ‚‚, R))","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"using RadiiPolynomial","category":"page"},{"location":"sequence_spaces/vector_spaces/#vector_spaces","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"RadiiPolynomial defines a variety of vector spaces to represent the Banach space on which one applies the Radii Polynomial Theorem.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"All spaces mentioned below are a subtype of the abstract type VectorSpace.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"VectorSpace\nâ”œâ”€ CartesianSpace\nâ”‚  â”œâ”€ CartesianPower\nâ”‚  â””â”€ CartesianProduct\nâ”œâ”€ ParameterSpace\nâ””â”€ SequenceSpace\n   â”œâ”€ BaseSpace\n   â”‚  â”œâ”€ Chebyshev\n   â”‚  â”œâ”€ Fourier\n   â”‚  â””â”€ Taylor\n   â””â”€ TensorSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"VectorSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.VectorSpace","page":"Vector spaces","title":"RadiiPolynomial.VectorSpace","text":"VectorSpace\n\nAbstract type for all vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Parameter-space","page":"Vector spaces","title":"Parameter space","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"A ParameterSpace represents the commutative field of a parameter. This is the standard space to use for an unfolding parameter.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"ğ’« = ParameterSpace()\ndimension(ğ’«)\nindices(ğ’«)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"ParameterSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.ParameterSpace","page":"Vector spaces","title":"RadiiPolynomial.ParameterSpace","text":"ParameterSpace <: VectorSpace\n\nSpace of a parameter corresponding to a commutative field.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Sequence-space","page":"Vector spaces","title":"Sequence space","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"SequenceSpace is the abstract type for all sequence spaces.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"SequenceSpace\nâ”œâ”€ BaseSpace\nâ”‚  â”œâ”€ Chebyshev\nâ”‚  â”œâ”€ Fourier\nâ”‚  â””â”€ Taylor\nâ””â”€ TensorSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"SequenceSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.SequenceSpace","page":"Vector spaces","title":"RadiiPolynomial.SequenceSpace","text":"SequenceSpace <: VectorSpace\n\nAbstract type for all sequence spaces.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#BaseSpace","page":"Vector spaces","title":"BaseSpace","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"BaseSpace is the abstract type for all sequence spaces that are not a TensorSpace but can be interlaced to form one.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"BaseSpace\nâ”œâ”€ Chebyshev\nâ”œâ”€ Fourier\nâ””â”€ Taylor","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"BaseSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.BaseSpace","page":"Vector spaces","title":"RadiiPolynomial.BaseSpace","text":"BaseSpace <: SequenceSpace\n\nAbstract type for all sequence spaces that are not a TensorSpace but can be interlaced to form one.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Taylor","page":"Vector spaces","title":"Taylor","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"For a given order n, a Taylor sequence space is the span of phi_0 dots phi_n where phi_k(t) = t^k for k = 0 dots n and t in -nu nu for some appropriate nu  0.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"ğ’¯ = Taylor(1)\norder(ğ’¯)\ndimension(ğ’¯)\nindices(ğ’¯)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"Taylor","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.Taylor","page":"Vector spaces","title":"RadiiPolynomial.Taylor","text":"Taylor <: BaseSpace\n\nTaylor sequence space whose elements are Taylor sequences of a prescribed order.\n\nFields:\n\norder :: Int\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Fourier","page":"Vector spaces","title":"Fourier","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"For a given order n and frequency omega, a Fourier sequence space is the span of phi_-n dots phi_n where phi_k(t) = e^i omega k t for k = -n dots n and t in mathbbR2piomega^-1mathbbZ.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"â„± = Fourier(1, 1.0)\norder(â„±)\nfrequency(â„±)\ndimension(â„±)\nindices(â„±)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"Fourier","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.Fourier","page":"Vector spaces","title":"RadiiPolynomial.Fourier","text":"Fourier{T} <: BaseSpace\n\nFourier sequence space whose elements are Fourier sequences of a prescribed order and frequency.\n\nFields:\n\norder :: Int\nfrequency :: T\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Chebyshev","page":"Vector spaces","title":"Chebyshev","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"For a given order n, a Chebyshev sequence space is the span of phi_0 2phi_1 dots 2phi_n where phi_0(t) = 1, phi_1(t) = t and phi_k(t) = 2 t phi_k-1(t) - phi_k-2(t) for k = 2 dots n and t in -1 1. The normalization by a factor 2 is done for convenience.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"ğ’ = Chebyshev(1)\norder(ğ’)\ndimension(ğ’)\nindices(ğ’)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"Chebyshev","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.Chebyshev","page":"Vector spaces","title":"RadiiPolynomial.Chebyshev","text":"Chebyshev <: BaseSpace\n\nChebyshev sequence space whose elements are Chebyshev sequences of a prescribed order.\n\nFields:\n\norder :: Int\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Tensor-space","page":"Vector spaces","title":"Tensor space","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"A TensorSpace is the tensor product of some BaseSpace. The standard constructor for TensorSpace is the âŠ— (\\otimes<TAB>) operator.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"ğ’¯_otimes_â„±_otimes_ğ’ = Taylor(1) âŠ— Fourier(1, 1.0) âŠ— Chebyshev(1) # TensorSpace((Taylor(1), Fourier(1, 1.0), Chebyshev(1)))\norder(ğ’¯_otimes_â„±_otimes_ğ’)\nfrequency(ğ’¯_otimes_â„±_otimes_ğ’, 2)\ndimension(ğ’¯_otimes_â„±_otimes_ğ’)\ndimensions(ğ’¯_otimes_â„±_otimes_ğ’)\nindices(ğ’¯_otimes_â„±_otimes_ğ’)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"TensorSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.TensorSpace","page":"Vector spaces","title":"RadiiPolynomial.TensorSpace","text":"TensorSpace{T<:NTuple{N,BaseSpace} where {N}} <: SequenceSpace\n\nSequenceSpace resulting from the tensor product of some BaseSpace.\n\nFields:\n\nspaces :: T\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Cartesian-space","page":"Vector spaces","title":"Cartesian space","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianSpace is the abstract type for all cartesian spaces.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianSpace\nâ”œâ”€ CartesianPower\nâ””â”€ CartesianProduct","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianSpace","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.CartesianSpace","page":"Vector spaces","title":"RadiiPolynomial.CartesianSpace","text":"CartesianSpace <: VectorSpace\n\nAbstract type for all cartesian spaces.\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Cartesian-power","page":"Vector spaces","title":"Cartesian power","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"A CartesianPower is the cartesian product of an identical VectorSpace. The standard constructor for CartesianPower is the ^ operator.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"ğ’¯Â² = Taylor(1) ^ 2 # CartesianPower(Taylor(1), 2)\nnb_cartesian_product(ğ’¯Â²)\ndimension(ğ’¯Â²)\nindices(ğ’¯Â²)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianPower","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.CartesianPower","page":"Vector spaces","title":"RadiiPolynomial.CartesianPower","text":"CartesianPower{T<:VectorSpace} <: CartesianSpace\n\nCartesian space resulting from the cartesian products of a VectorSpace.\n\nFields:\n\nspace :: T\nn :: Int\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/vector_spaces/#Cartesian-product","page":"Vector spaces","title":"Cartesian product","text":"","category":"section"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"A CartesianProduct is the cartesian product of some VectorSpace. The standard constructor for CartesianProduct is the Ã— (\\times<TAB>) operator.","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"ğ’«_times_ğ’¯ = ParameterSpace() Ã— Taylor(1) # CartesianProduct((ParameterSpace(), Taylor(1)))\nnb_cartesian_product(ğ’«_times_ğ’¯)\ndimension(ğ’«_times_ğ’¯)\nindices(ğ’«_times_ğ’¯)","category":"page"},{"location":"sequence_spaces/vector_spaces/","page":"Vector spaces","title":"Vector spaces","text":"CartesianProduct","category":"page"},{"location":"sequence_spaces/vector_spaces/#RadiiPolynomial.CartesianProduct","page":"Vector spaces","title":"RadiiPolynomial.CartesianProduct","text":"CartesianProduct{T<:NTuple{N,VectorSpace} where {N}} <: CartesianSpace\n\nCartesian space resulting from N cartesian products of some VectorSpace.\n\nFields:\n\nspaces :: T\n\n\n\n\n\n","category":"type"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/#Pseudo-arclength-continuation","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"","category":"section"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"In this example, we will prove the existence of a branch of equilibria for the FitzHugh-Nagumo model","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"begincases\ndisplaystyle fracddt u(t) = f(gamma u(t)) = beginpmatrix u_1(t)(u_1(t) - a)(1 - u_1(t)) - u_2(t)  varepsilon(u_1(t) - gamma u_2(t)) endpmatrix\nu(0) = u_0 in mathbbR^2\nendcases","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"where a = 5 and varepsilon = 1.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"To this end, we use the pseudo-arclength continuation and prove, at each step, that there exists a box, surrounding the linear numerical approximation, which contains the desired curve.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"In a nutshell, the pseudo-arclength continuation consists in computing a sequence of numerical zeros of f. Starting with an initial zero x_1 in mathbbR^3, we retrieve an approximate tangent vector v_1 to the curve at x_1 by looking at ker Df(x_1). Then, our predictor for the next zero is set to w = x_1 + delta v_1 where delta  0 represents the step size. The Newton's method is applied on the mapping F_textNewton  mathbbR^3 to mathbbR^3 given by","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"F_textNewton(x) =\nbeginpmatrix\n(x - w_1) cdot v_1\nf(x)\nendpmatrix","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"Once the Newton's method converged to some x_2 in mathbbR^3, we make a linear approximation of the curve of zeros and successive tangent vectors","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"beginaligned\nx_0(s) = x_1 + s (x_2 - x_1) qquad textfor all  s in 01\nv_0(s) = v_1 + s (v_2 - v_1) qquad textfor all  s in 01\nendaligned","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"Define the mapping F  mathbbR^3 times 01 to mathbbR^3 by","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"F(x s) =\nbeginpmatrix\n(x - x_0(s)) cdot v_0(s)\nf(x)\nendpmatrix","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"and the fixed-point operator T  mathbbR^3 times 01 to mathbbR^3 by","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"T(x s) = x - A F(x s)","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"Let R  0. According to the Radii Polynomial Theorem, we need to estimate uniform bounds for T(x_0(s) s) - x_0(s)_infty and sup_y in textcl( B_R(x_0(s)) ) DT(y s)_infty for all s in 01. In particular, we have","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"T(x_0(s) s) - x_0(s)_infty = leftA beginpmatrix 0  f(x_0(s)) endpmatrix right_infty qquad textfor all  s in 01","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"Whenever the proof is successful, we proceed to the next iteration of the pseudo-arclength continuation and repeat the above strategy.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"We can now write our computer-assisted proof:","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"using RadiiPolynomial\n\nfunction rigorous_pseudo_arclength(x_ini::Vector{Float64}, step_size::Float64, max_iter::Int)\n    n = length(x_ini)\n    ie_collection = Interval{Float64}[]\n    x_collection = [x_ini]\n    Î´_collection = Float64[]\n    Î´ = step_size\n\n    # initialize variables for Newton's method\n    Df = Matrix{Float64}(undef, n-1, n)\n    v = vec(nullspace(Df!(Df, x_ini)))\n    w = Vector{Float64}(undef, n)\n    x = Vector{Float64}(undef, n)\n    F = Vector{Float64}(undef, n)\n    DF = Matrix{Float64}(undef, n, n)\n\n    # initialize variables for the proof\n    R = 1e-2\n    s = Interval(0.0, 1.0)\n    Df_interval = Matrix{Interval{Float64}}(undef, n-1, n)\n    v_interval = Vector{Interval{Float64}}(undef, n)\n    xâ‚€_interval = Vector{Interval{Float64}}(undef, n)\n    xâ‚€R_interval = Vector{Interval{Float64}}(undef, n)\n    F_interval = Vector{Interval{Float64}}(undef, n)\n    DF_interval = Matrix{Interval{Float64}}(undef, n, n)\n    Î©â‚ = Vector{Interval{Float64}}(undef, n)\n    Î©â‚‚ = Matrix{Interval{Float64}}(undef, n, n)\n\n    k = 1\n    while k â‰¤ max_iter && Î´ â‰¥ 1e-8\n        w .= x_collection[end] .+ Î´ .* v\n        x .= w\n        x, success = newton!(F_DF_NewtonPseudoArclength!(w, v),\n            x, F, DF;\n            tol = 1e-15, verbose = false)\n        if success\n            v_ = v\n            v = vec(nullspace(Df!(Df, x)))\n            if v â‹… v_ < 0\n                v .= (-).(v)\n            end\n            if v == v_\n                v_interval .= Interval.(v_)\n            else\n                v_interval .= v_ .+ s .* Interval.(v .- v_)\n            end\n            xâ‚€_interval .= Interval.(x_collection[end]) .+ s .* (Interval.(x) .- Interval.(x_collection[end]))\n            xâ‚€R_interval .= Interval.(inf.(xâ‚€_interval .- R), sup.(xâ‚€_interval .+ R))\n            F_DF_ProofPseudoArclength!(F_interval, DF_interval, xâ‚€_interval, xâ‚€R_interval, v_interval)\n            DF .= mid.(DF_interval)\n            A = inv(DF)\n\n            Î©â‚ .= Interval.(mag.(A * F_interval))\n            Î©â‚‚ .= Interval.(mag.(A * DF_interval - I))\n            Y = norm(Î©â‚, Inf)\n            Zâ‚ = opnorm(Î©â‚‚, Inf)\n            ie = interval_of_existence(Y, Zâ‚, R)\n            if isempty(ie)\n                Î´ /= 2\n            else\n                push!(x_collection, copy(x))\n                push!(Î´_collection, Î´)\n                push!(ie_collection, ie)\n                Î´ *= 2\n            end\n        else\n            Î´ /= 2\n        end\n        k += 1\n    end\n\n    return x_collection, Î´_collection, ie_collection\nend\n\nstruct F_DF_NewtonPseudoArclength!\n    w :: Vector{Float64}\n    v :: Vector{Float64}\nend\n\nfunction (F_DF!::F_DF_NewtonPseudoArclength!)(F, DF, x)\n    n = length(x)\n    F[1] = (x - F_DF!.w) â‹… F_DF!.v\n    f!(view(F, 2:n), x)\n    DF[1,:] .= F_DF!.v\n    Df!(view(DF, 2:n, :), x)\n    return F, DF\nend\n\nfunction F_DF_ProofPseudoArclength!(F, DF, x, xR, v)\n    n = length(x)\n    F[1] = 0\n    f!(view(F, 2:n), x)\n    DF[1,:] .= v\n    Df!(view(DF, 2:n, :), xR)\n    return F, DF\nend\n\n# in-place FitzHugh-Nagumo model\n\nfunction f!(f, x)\n    a, Ïµ = 5, 1\n    Î³, uâ‚, uâ‚‚ = x\n    f[1] = uâ‚*(uâ‚ - a)*(1 - uâ‚) - uâ‚‚\n    f[2] = Ïµ*(uâ‚ - Î³*uâ‚‚)\n    return f\nend\n\nfunction Df!(Df, x)\n    a, Ïµ = 5, 1\n    Î³, uâ‚, uâ‚‚ = x\n    Df[1,1] = 0\n    Df[1,2] = a*(2uâ‚ - 1) + (2 - 3uâ‚)*uâ‚\n    Df[1,3] = -1\n    Df[2,1] = -Ïµ*uâ‚‚\n    Df[2,2] = Ïµ\n    Df[2,3] = -Ïµ*Î³\n    return Df\nend\n\nx, Î´, ie = rigorous_pseudo_arclength([2, 1.129171306613029, 0.564585653306514], 0.1, 3_000)","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"The following figure shows the numerical approximation of the branch of equilibria for the FitzHugh-Nagumo model.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"(Image: )","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"The following figure shows the sharpest computed a posteriori error bound for each numerical approximation of a piece of the branch of equilibria for the FitzHugh-Nagumo model.","category":"page"},{"location":"examples/finite_dimensional_proofs/pseudo_arclength/","page":"Pseudo-arclength continuation","title":"Pseudo-arclength continuation","text":"(Image: )","category":"page"},{"location":"#Presentation","page":"Home","title":"Presentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The solution of many problems in dynamical systems can be seen as the fixed point of an operator. In computer-assisted proofs, the Radii Polynomial Theorem gives us closed ball(s), centred at a numerical approximation of the fixed point, within which the operator satisfies the Banach Fixed Point Theorem.[1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: For Newton-like operators, the Radii Polynomial Theorem is an instance of the Newton-Kantorovich Theorem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hence, the desired solution is the unique fixed point within the ball(s) whose radius yields an a posteriori error bound on the numerical approximation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"RadiiPolynomial.jl is a Julia package to conduct the computational steps of the Radii Polynomial Theorem which entails rigorous arithmetic (cf. IntervalArithmetic.jl).","category":"page"},{"location":"","page":"Home","title":"Home","text":"When the solution lies in a Banach space involving function spaces, the standard approach is to interpret the function spaces as sequence spaces. Thus, RadiiPolynomial is concerned with the latter (cf. ApproxFun.jl for a Julia package to approximate functions).","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use the RadiiPolynomial software in your publication, research, teaching, or other activities, please use the following BibTeX entry (cf. CITATION.bib):","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{RadiiPolynomial.jl,\n  author = {Olivier HÃ©not},\n  title  = {RadiiPolynomial.jl},\n  url    = {https://github.com/OlivierHnt/RadiiPolynomial.jl}\n}","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/#Spiderweb-central-configurations","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"","category":"section"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"In this example, we will prove the existence and local uniqueness of a central configuration in the N-body problem.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"More precisely, we will look at configurations given by N = n times ell+1 masses located at the intersection points of ell concurrent equidistributed half-lines with n circles and a central mass m_0. The ell masses on the i-th circle are equal to a positive constant m_i and we allow the particular case m_0 = 0. These central configurations are called spiderweb central configurations.[1]","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"[1]: O. HÃ©not and C. Rousseau, Spiderweb central configurations, Qualitative Theory of Dynamical Systems, 18 (2019), 1135â€“1160.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"The N-body problem consists in describing the positions mathbfr_1(t)dotsmathbfr_N(t) of N masses m_1dotsm_N interacting through Newton's gravitational law:","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"m_i fracd^2dt^2 mathbfr_i\n=\n-sum_jneq i fracG m_i m_j(mathbfr_i - mathbfr_j) mathbfr_i - mathbfr_j ^3\n=\n-fracpartialpartial mathbfr_i U (mathbfr)\nqquad\nU (mathbfr)\n=\n-sum_ij fracG m_i m_jmathbfr_i-mathbfr_j","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"for i = 1dotsN, with mathbfr in  (mathbfr_1dotsmathbfr_N) in R^3N    mathbfr_i neq mathbfr_j    i neq j, where G denotes the gravitational constant.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"In the following, we fix the centre of mass at the origin and scale G = 1. Moreover, due to the symmetries of a spiderweb central configuration, it is sufficient to consider the accelerations of the n bodies on the positive horizontal axis, and the numbers r_1 dots r_n also denote the positions of the masses on this semi-axis.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"The configuration of N bodies is central at some time t^* if fracd^2dt^2mathbfr(t^*) = lambda mathbfr(t^*) for some common lambda. It is easy to see that lambda is a strictly negative value given by lambda = U(mathbfr)I(mathbfr)  0 where I = sum_i = 1^N m_i mathbfr_i(mathbfr)^2 is the moment of inertia. Essentially, the value of lambda scales the system and can be chosen arbitrarily.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"Then, the original system of ODEs reduces to the following system of equations in mathbbR^n:","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"lambda r_i\n=\n-sum_k=1^ell-1 fracm_i 2^32r_i^2( 1 - cos theta_k )^12 -frac m_0 r_i^2 - sum_beginsmallmatrixj=1jneq i endsmallmatrix^n sum_k=0^ell-1 fracm_j( r_i - r_j cos theta_k )( r_i^2 + r_j^2 - 2 r_i r_j cos theta_k )^32","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"for i = 1 dots n, with theta_k = frac2pi kell and r = (r_1dotsr_n) in  r in R^n    0  r_1  ldots  r_n.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"Thus, a spiderweb central configuration is a zero of the mapping F = (F_1 dots F_n)  mathbbR^n to mathbbR^n given by","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"F_i(r) =\nlambda  r_i + frac m_i 2^32r_i^2zeta_ell + frac m_0r_i^2 + sum_beginsmallmatrixj=1jneq i endsmallmatrix^n sum_k=0^ell-1 fracm_j( r_i - r_j cos theta_k )( r_i^2 + r_j^2 - 2 r_i r_j cos theta_k )^32  qquad i =1 dots n","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"where zeta_ell = sum_k=1^ell-1 (1-cos theta_k)^-12.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"The Jacobian matrix is given by","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"fracpartialpartial r_j F_i(r) =\nbegincases\ndisplaystyle lambda - frac m_i r_i^3sqrt2zeta_ell - frac 2m_0 r_i^3\n-sum_beginsmallmatrixj=1jneq i endsmallmatrix^n fracm_j2sum_k=0^ell-1\nfrac4r_i^2+r_j^2-8 r_i r_j cos theta_k + 3 r_j^2 cos 2theta_k( r_i^2 + r_j^2 - 2 r_i r_j cos theta_k )^52 j=i\ndisplaystyle -fracm_j2 sum_k=0^ell-1\nfrac-4(r_i^2+r_j^2)cos theta_k + r_i r_j (7+ cos 2theta_k)( r_i^2 + r_j^2 - 2 r_i r_j cos theta_k)^52  jneq i\nendcases","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"Consider the fixed-point operator T  mathbbR^n to mathbbR^n defined by","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"T(x) = x - A F(x)","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"where A  mathbbR^n to mathbbR^n is the injective operator corresponding to a numerical approximation of DF(x_0)^-1 for some numerical zero x_0 in mathbbR^n of F.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"Let R  0. According to the Radii Polynomial Theorem, we need to estimate T(x_0) - x_0_infty and sup_y in textcl( B_R(x_0) ) DT(y)_infty which can be readily computed with interval arithmetic.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"We can now write our computer-assisted proof:","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"using RadiiPolynomial\n\nfunction F_DF!(F::Vector{T}, DF::Matrix{T}, x::Vector{T}, xR::Vector{T}, mâ‚€::T, m::Vector{T}, Î»::T, n::Int, l::Int) where {T}\n    length(F) == size(DF, 1) == size(DF, 2) == length(x) == length(xR) == length(m) || return throw(DimensionMismatch)\n    Ï€2_l = 2convert(T, Ï€)/l\n    sqrt2 = sqrt(convert(T, 2))\n    DF .= Matrix{T}(I*Î», n, n)\n    @inbounds for j âˆˆ axes(DF, 2)\n        xâ±¼Â² = x[j]*x[j]\n        xRâ±¼Â² = xR[j]*xR[j]\n        @inbounds for i âˆˆ axes(DF, 1)\n            xáµ¢Â², xáµ¢xâ±¼ = x[i]*x[i], x[i]*x[j]\n            xRáµ¢Â², xRáµ¢xRâ±¼ = xR[i]*xR[i], xR[i]*xR[j]\n            xRáµ¢Â³ = xRáµ¢Â²*xR[i]\n            if j == 1\n                F[i] = Î»*x[i] + mâ‚€/xáµ¢Â²\n            end\n            if i == j\n                DF[i,j] -= 2mâ‚€/xRáµ¢Â³\n            end\n            @inbounds for k âˆˆ 0:l-1\n                Î¸ = k*Ï€2_l\n                cosÎ¸ = cos(Î¸)\n                cos2Î¸ = cos(2Î¸)\n                if i â‰  j\n                    d = sqrt(xáµ¢Â² + xâ±¼Â² - 2xáµ¢xâ±¼*cosÎ¸)\n                    dáµ£ = sqrt(xRáµ¢Â² + xRâ±¼Â² - 2xRáµ¢xRâ±¼*cosÎ¸)\n                    dáµ£âµ2 = 2dáµ£*dáµ£*dáµ£*dáµ£*dáµ£\n                    F[i] += m[j]*(x[i] - x[j]*cosÎ¸)/(d*d*d)\n                    DF[i,i] -= m[j]*(4xRáµ¢Â² + xRâ±¼Â² - 8xRáµ¢xRâ±¼*cosÎ¸ + 3xRâ±¼Â²*cos2Î¸)/dáµ£âµ2\n                    DF[i,j] -= m[j]*(-4(xRáµ¢Â² + xRâ±¼Â²)*cosÎ¸ + xRáµ¢xRâ±¼*(7 + cos2Î¸))/dáµ£âµ2\n                elseif i == j && k > 0\n                    Î¶ = sqrt2*sqrt(1-cosÎ¸)\n                    F[i] += m[i]/(2xáµ¢Â²*Î¶)\n                    DF[i,j] -= m[i]/(xRáµ¢Â³*Î¶)\n                end\n            end\n        end\n    end\n    return F, DF\nend\n\nn = 18 # number of circles\nl = 100 # number of masses per circle\n\n# numerical solution\n\nmâ‚€ = 0.0 # central mass\nm = fill(1/l, n) # vector of masses\nÎ» = -1.0\n\nxâ‚€ = float.(1:n)\nF = Vector{Float64}(undef, n)\nDF = Matrix{Float64}(undef, n, n)\nnewton!((F, DF, x) -> F_DF!(F, DF, x, x, mâ‚€, m, Î», n, l),\n    xâ‚€, F, DF;\n    tol = 1e-12, maxiter = 50, verbose = false)\nsort!(xâ‚€)\n\n# proof\n\nmâ‚€_interval = Interval(0.0)\nm_interval = fill(@interval(1/l), n)\nÎ»_interval = Interval(-1.0)\n\nR = 1e-12\n\nxâ‚€_interval = Interval.(xâ‚€)\nxâ‚€R_interval = Interval.(inf.(xâ‚€_interval .- R), sup.(xâ‚€_interval .+ R))\nF_interval = Vector{Interval{Float64}}(undef, n)\nDF_interval = Matrix{Interval{Float64}}(undef, n, n)\nF_DF!(F_interval, DF_interval, xâ‚€_interval, xâ‚€R_interval, mâ‚€_interval, m_interval, Î»_interval, n, l)\nA = inv(mid.(DF_interval))\n\nY = norm(Interval.(mag.(A * F_interval)), Inf)\nZâ‚ = opnorm(Interval.(mag.(A * DF_interval - I)), Inf)\nshowfull(interval_of_existence(Y, Zâ‚, R))","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"The following figure shows the numerical approximation of the spiderweb central configuration.","category":"page"},{"location":"examples/finite_dimensional_proofs/spiderweb/","page":"Spiderweb central configurations","title":"Spiderweb central configurations","text":"(Image: )","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"using RadiiPolynomial","category":"page"},{"location":"sequence_spaces/sequences/#Sequences","page":"Sequences","title":"Sequences","text":"","category":"section"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"A Sequence is a structure representing a sequence in a prescribed VectorSpace. More precisely, a Sequence is comprised of the two fields space::VectorSpace and coefficients::AbstractVector with matching dimension and length.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"a = Sequence(Taylor(1), [1, 2])","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The two fields space and coefficients are accessible via the respective functions of the same name.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"space(a)\ncoefficients(a)","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The coefficients of a Sequence are indexed according to the indices of the space (as given by indices).","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"a[0:1] # indices(space(a))","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"When the space of a Sequence is a CartesianSpace, its coefficients are given as the concatenation of the coefficients associated with each space. The function component extracts a Sequence composing the cartesian space.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"b = Sequence(ParameterSpace() Ã— Taylor(1)^2, [1, 2, 3, 4, 5])\nb[1:5] # indices(space(b))\ncomponent(b, 1) # extract the sequence associated with the space ParameterSpace()\ncomponent(b, 2) # extract the sequence associated with the space Taylor(1)^2\ncomponent(component(b, 2), 1)\ncomponent(component(b, 2), 2)","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"Similarly, the function eachcomponent returns a Generator whose iterates yield the each Sequence composing the cartesian space.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"Sequence","category":"page"},{"location":"sequence_spaces/sequences/#RadiiPolynomial.Sequence","page":"Sequences","title":"RadiiPolynomial.Sequence","text":"Sequence{T<:VectorSpace,S<:AbstractVector}\n\nCompactly supported sequence of the given space.\n\nFields:\n\nspace :: T\ncoefficients :: S\n\n\n\n\n\n","category":"type"},{"location":"sequence_spaces/sequences/#Arithmetic","page":"Sequences","title":"Arithmetic","text":"","category":"section"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The addition and subtraction operations are implemented as the + and - functions respectively. Their bar counterparts +Ì„ (+\\bar<TAB>) and -Ì„ (-\\bar<TAB>) give the result projected in the smallest compatible space between the operands.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"c = Sequence(Taylor(1), [0, 1])\nd = Sequence(Taylor(2), [1, 2, 1])\nc + d\nc - d\nc +Ì„ d # project(c + d, Taylor(1))\nc -Ì„ d # project(c - d, Taylor(1))","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The discrete convolution between sequences whose spaces are a SequenceSpace is implemented as the * and ^ functions. Their bar counterparts *Ì„ (*\\bar<TAB>) and ^Ì„ (^\\bar<TAB>) give the result projected in the smallest compatible space between the operands; in general, *Ì„ is not associative.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"c * d\nc ^ 3\nc *Ì„ d # project(c * d, Taylor(1))\nc ^Ì„ 3 # project(c ^ 3, Taylor(1))","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"To improve performance, the FFT algorithm may be used to compute discrete convolutions via the Convolution Theorem. However, the performance gain is tempered with the loss of accuracy which may stop the decay of the coefficients.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"x = Sequence(Taylor(3), Interval.([inv(10_000.0 ^ i) for i âˆˆ 0:3]))\nxÂ³ = x ^ 3\nxÂ³_fft = rifft!(similar(xÂ³), fft(x, fft_size(space(x), 3)) .^ 3)","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"To circumvent machine precision limitations, the banach_rounding! method enclose rigorously each term of the convolution beyond a prescribed order.[1]","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"[1]: J.-P. Lessard, Computing discrete convolutions with verified accuracy via Banach algebras and the FFT, Applications of Mathematics, 63 (2018), 219-235.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"The rounding strategy for *, ^, *Ì„ and ^Ì„ is integrated in the functions banach_rounding_mul, banach_rounding_pow, banach_rounding_mul_bar and banach_rounding_pow_bar respectively.","category":"page"},{"location":"sequence_spaces/sequences/","page":"Sequences","title":"Sequences","text":"weights = GeometricWeights(Interval(10_000.0))\nnorm_x = norm(x, Weightedâ„“Â¹Norm(weights))\nbanach_rounding!(xÂ³_fft, weights, norm_x ^ 3, 5)","category":"page"}]
}
